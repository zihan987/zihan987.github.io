<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zihan987.github.io</id>
    <title>阿chai带你学AI</title>
    <updated>2021-08-18T16:02:55.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zihan987.github.io"/>
    <link rel="self" href="https://zihan987.github.io/atom.xml"/>
    <subtitle>小镇青年，不偷电瓶，chai哩chai气</subtitle>
    <logo>https://zihan987.github.io/images/avatar.png</logo>
    <icon>https://zihan987.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 阿chai带你学AI</rights>
    <entry>
        <title type="html"><![CDATA[算法工程师惨遭毒虫叮咬，感染了！]]></title>
        <id>https://zihan987.github.io/post/suan-fa-gong-cheng-shi-can-zao-du-chong-ding-yao-gan-ran-liao/</id>
        <link href="https://zihan987.github.io/post/suan-fa-gong-cheng-shi-can-zao-du-chong-ding-yao-gan-ran-liao/">
        </link>
        <updated>2021-08-18T15:58:05.000Z</updated>
        <summary type="html"><![CDATA[<p>阿chai昨天被一个毒虫子咬了。原本只是红肿，后来变成了出“脓”了，而且是一大片。在经历了一系列检查后医生给阿chai开了很多药，内服外敷的都有，还有激素成分的药物。</p>
]]></summary>
        <content type="html"><![CDATA[<p>阿chai昨天被一个毒虫子咬了。原本只是红肿，后来变成了出“脓”了，而且是一大片。在经历了一系列检查后医生给阿chai开了很多药，内服外敷的都有，还有激素成分的药物。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://zihan987.github.io/post-images/1629302334603.png" alt="" loading="lazy"></figure>
<p>阿chai在这里提醒小伙伴们，最近真的少往草和树多的地方去，秋天就算是蚊子咬人都很厉害的。既然虫子这么讨厌，那今天来个昆虫识别的demo吧，机器人得“吸取”阿chai的教训，不能被啃啊。</p>
<h3 id="1蜘蛛侠也被咬了">1.蜘蛛侠也被咬了</h3>
<p>呃呃呃，蜘蛛侠是蜘蛛侠，阿chai是阿chai，蜘蛛侠能在绿布前表演，阿chai能电脑前码字，认真就输了。</p>
<figure data-type="image" tabindex="2"><img src="https://zihan987.github.io/post-images/1629302397777.jpeg" alt="" loading="lazy"></figure>
<p>小伙伴们，被蛇虫咬了一定要去医院，真的，别拖，去了天堂也变不成蜘蛛侠。</p>
<h3 id="2faster-rcnn">2.Faster-RCNN</h3>
<p>Faster-RCNN是非常优秀的目标检测框架，是Fast RCNN的优化版本，二者主要的不同在于感兴趣区域的生成方法，Fast RCNN使用的是选择性搜索，而Faster RCNN用的是RPN网络。RPN将图像特征映射作为输入，生成一系列object proposals，每个都带有相应的分数。</p>
<h4 id="a开源demo与paper">a.开源demo与paper</h4>
<pre><code class="language-markdown">Paper:https://www.aliyundrive.com/s/fr12aE6n46E
Caffe:https://github.com/rbgirshick/py-faster-rcnn.git
PyTorch:https://github.com/jwyang/faster-rcnn.pytorch.git
TensorFlow:https://github.com/smallcorgi/Faster-RCNN_TF.git
Keras:https://github.com/you359/Keras-FasterRCNN.git
</code></pre>
<h4 id="b工作流程">b.工作流程</h4>
<p>（1）输入图像到卷积网络中，生成该图像的特征映射。</p>
<p>（2）在特征映射上应用RPN，返回object proposals和对应的分数。</p>
<p>（3）应用Rol池化层，将所有proposals修正到同样尺寸。</p>
<p>（4）将proposals传递到完全连接层，生成目标物体的边界框。</p>
<figure data-type="image" tabindex="3"><img src="https://zihan987.github.io/post-images/1629302414325.png" alt="" loading="lazy"></figure>
<h4 id="c工作点">c.工作点</h4>
<ul>
<li>卷基层：Faster RCNN使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</li>
<li>RPN：RPN用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</li>
<li>Roi Pooling：该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</li>
<li>分类器：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li>
</ul>
<h3 id="3faster-rcnn的昆虫检测">3.Faster-RCNN的昆虫检测</h3>
<p>这里我们依托百度飞桨的PaddleX，小伙伴们也可以在AIStudio上运行。</p>
<h4 id="a环境准备">a.环境准备</h4>
<p>在安装好Miniconda或Anaconda后我们新建一个环境：</p>
<pre><code class="language-bash"># 新建环境
conda create -n insect_detection python=3.7
conda activate insect_detection
# paddlepaddle 1.8.4
pip install paddlepaddle-gpu=1.8.4
# 静态图
pip install &quot;paddlex&lt;=2.0.0&quot; -i https://mirror.baidu.com/pypi/simple

tar xzf insect_det.tar.gz
</code></pre>
<p>然后下载阿chai准备的代码、数据以及模型文件：</p>
<pre><code class="language-bash">git clone https://github.com/zihan987/insects_detection.git
</code></pre>
<pre><code>https://pan.baidu.com/s/1VuURAeh610r-gQRO8ROBxg
提取码：fp5n
</code></pre>
<p>insect文件解压后，fasterrcnn_model.zip为阿chai训练的模型，insect_det.tar.gz为标注好的昆虫数据。</p>
<h4 id="b训练模型">b.训练模型</h4>
<p>如果想自己训练，阿chai提供了训练的代码，在<a href="https://github.com/zihan987/insects_detection/blob/main/train.py">train.py</a>中。我们运行即可进行测试，注意修改数据的路径。</p>
<pre><code class="language-bash">python train.py
</code></pre>
<p>训练一定找一个GPU服务器，或者在AIStudio上运行。</p>
<figure data-type="image" tabindex="4"><img src="https://zihan987.github.io/post-images/1629302428871.png" alt="" loading="lazy"></figure>
<p>阿chai只是训练了20个epoch，小伙伴们可以增加训练轮数。</p>
<h4 id="c测试效果">c.测试效果</h4>
<p>阿柴提供了训练的代码，在<a href="https://github.com/zihan987/insects_detection/blob/main/test.py">test.py</a>中，我们可以运行进行测试。</p>
<pre><code class="language-bash">python test.py
</code></pre>
<p>在保存的文件夹中可找到效果图片。</p>
<figure data-type="image" tabindex="5"><img src="https://zihan987.github.io/post-images/1629302452858.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[论文分享：基于场景的自动驾驶汽车自动化安全测试的方法]]></title>
        <id>https://zihan987.github.io/post/lun-wen-fen-xiang-ji-yu-chang-jing-de-zi-dong-jia-shi-qi-che-zi-dong-hua-an-quan-ce-shi-de-fang-fa/</id>
        <link href="https://zihan987.github.io/post/lun-wen-fen-xiang-ji-yu-chang-jing-de-zi-dong-jia-shi-qi-che-zi-dong-hua-an-quan-ce-shi-de-fang-fa/">
        </link>
        <updated>2021-08-17T08:54:07.000Z</updated>
        <summary type="html"><![CDATA[<p>今天给大家分享一篇加州大学伯克利学校的paper，文中以LGSVL仿真器为例，提出一种基于场景的自动驾驶汽车自动化安全测试的方法，尤其针对AI模组模拟仿真评估和真实驾驶测试。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天给大家分享一篇加州大学伯克利学校的paper，文中以LGSVL仿真器为例，提出一种基于场景的自动驾驶汽车自动化安全测试的方法，尤其针对AI模组模拟仿真评估和真实驾驶测试。</p>
<!-- more -->
<p>可以通过根据碰撞数据分析和自然驾驶数据分析创建的场景来构建测试集，这些场景利用人类驾驶数据来生成测试场景。</p>
<p>paper链接：<a href="https://www.aliyundrive.com/s/Wvq56JtXXRA">https://www.aliyundrive.com/s/Wvq56JtXXRA</a></p>
<p>ASAM规定了ADAS仿真场景准：<strong>OpenDRIVE</strong>、<strong>OpenSCENARIO</strong>、<strong>OpenCRG</strong>。分别对应静态路网、动态场景、路面材质。三者联合组成专用ADAS测试的场景库。</p>
<h3 id="1-仿真工具">1. 仿真工具</h3>
<p><strong>OpenSCENARIO</strong> 定义了一种文件格式，基于可扩展标记语言 (extensible markup language，XML)描述驾驶和交通模拟器的动态内容。</p>
<p>伯克利提出一种高级语言<strong>SCENIC</strong>，对比<strong>M-SDL</strong>可测场景描述语言是最近的一种类似于 SCENIC 更高级 DSL，但对于概率、几何建模的支持不如<strong>SCENIC</strong>。</p>
<p>伯克利开源<strong>VERIFAI</strong>工具包，提供了一个统一框架来设计和分析基于AI/ML的cyber-physical系统，VERIFAI 首先明确定义参数范围，或可以用SCENIC 语言来参数化感兴趣的环境空间和系统配置。工具包的地址如下。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/lgsvl/simulator">https://link.zhihu.com/?target=https%3A//github.com/lgsvl/simulator</a></p>
<h3 id="2-仿真步骤">2. 仿真步骤</h3>
<figure data-type="image" tabindex="1"><img src="https://zihan987.github.io/post-images/1629190605780.png" alt="" loading="lazy"></figure>
<h4 id="a-环境构建">a. 环境构建</h4>
<p>使用LGSVL仿真作为仿真场景的搭建软件，环境通过收集数百GB的激光雷达点云、相机图像和位置数据创建，所有的数据转化为3D网格。网格被加载到 LGSVL 模拟器去注释可行驶区域的细节，包括车道线、人行横道、交通标志等。</p>
<figure data-type="image" tabindex="2"><img src="https://zihan987.github.io/post-images/1629190620236.png" alt="" loading="lazy"></figure>
<p>上图为场景的BEV图，自驾车在十字路口右转，遇到一个犹豫不决地过马路的行人，自动驾驶系统控制车辆直接通过。</p>
<h4 id="b仿真脚本">b.仿真脚本</h4>
<p>如下为测试场景编码的<strong>SCENIC</strong>程序：</p>
<pre><code class="language-python">ego = TgoCar at 38.6 @ 183.9,
			facing 10 deg relative to roadDirection,
			with behavior DriverTo(40 @ 225.2)
ped = Pedestrian at 19.782 @ 225.680,
			facting 90 deg relative to roadDirection,
  		with behavior hesitate,
      with startDelay (7, 15),
      with walkDistance (4, 7),
      with hesitateTime (1, 3)
</code></pre>
<h4 id="c场景生成">c.场景生成</h4>
<p>定义SCENIC 程序之后，用 VERIFAI 来伪造场景，从分布中采样参数，在 LGSVL 模拟器中运行相应测试，并监视违反“安全”规范的情况。 一共生成1294 个测试用例，其中 2% 违反“安全”规范。 VERIFAI 的误差表存储所有此类情况的参数值，以及规范的定量满意度值；实验中将 VERIFAI 配置为存储安全运行，并且区分稳健安全的运行和几乎事故的运行。</p>
<h3 id="3实验数据">3.实验数据</h3>
<p>测试车是 林肯 MKZ 混合动力车，用**DataSpeed **线控功能和多个传感器进行增强，包括一个 <strong>Velodyne VLS-128 LiDAR</strong>、三个USB 摄像头和一个RTK  Novatel PwrPak7 双天线 GPS/IMU，保证 2 厘米的位置精度。 使用GPU GTX-1080TI的 x86 工控机，采用开源 Apollo 3.5自动驾驶软件进行测试。</p>
<p>为了帮助track testing的实现，固定自驾车和行人的初始位置和方向，并将行人轨迹定义为具有 3 个参数的直线：delay-过马路的延迟时间、distance-犹豫前行走距离和time-犹豫的时间。</p>
<p>如图是Satisfaction value，关于延迟delay和距离distance的函数：</p>
<figure data-type="image" tabindex="3"><img src="https://zihan987.github.io/post-images/1629190663538.png" alt="" loading="lazy"></figure>
<p>其中可以看到两个明显的聚类，左下方和右上方。为此选择了7个测试用例，两个失败（不安全），两个成功（安全）和3个中间（勉强安全）。</p>
<p>在 GoMentum 执行 7 个测试用例，其参数如表所示。</p>
<figure data-type="image" tabindex="4"><img src="https://zihan987.github.io/post-images/1629190675289.png" alt="" loading="lazy"></figure>
<p>对每个测试场景进行了多次运行，总共获得了 23 次运行。</p>
<figure data-type="image" tabindex="5"><img src="https://zihan987.github.io/post-images/1629190688683.png" alt="" loading="lazy"></figure>
<p>橘黄色标注显示是违反“安全”的运行，而白色行满足“安全”。 突出显示行的颜色表示不安全行为的程度：红色代表碰撞，橙色代表在视觉上归类为接近碰撞，黄色表示违反“安全但不是接近碰撞” 。</p>
<p>下图是是两个测试用例的轨迹：track test和5次再仿真，自驾车（绿色/蓝色）和行人（橙色和黄色）的轨迹</p>
<figure data-type="image" tabindex="6"><img src="https://zihan987.github.io/post-images/1629190703503.png" alt="" loading="lazy"></figure>
<p>模拟轨迹和真实轨迹显示重叠很多，但也存在差异：例如，尽管希望模拟的自驾车，从真实轨迹相同的位置开始，但阿波罗系统拒绝从该位置开始行驶，不得不对其进行略微调整。 更有趣的是，模拟的自驾车转弯比真实的更急，可能是模拟器对上坡驾驶的影响不精确建模造成。 最后，5 个模拟紧密聚集，但并不完全相同，这表明即使是单个测试用例也可以产生一系列不同的模拟轨迹。</p>
<figure data-type="image" tabindex="7"><img src="https://zihan987.github.io/post-images/1629190712039.png" alt="" loading="lazy"></figure>
<p>上表是是真实和重仿真轨迹之间的平均距离：<strong>Skorokhod metric</strong>测量两个定时轨迹的最坏情况偏差，可用于证明一致性，即<strong>Skorokhod metric</strong>显示的模拟轨迹与真实轨迹之间界限，允许从模拟到现实的迁移；<strong>Dynamic Time Warping (DTW) distance</strong>则给出整个轨迹而不是最坏点的平均相似性度量。</p>
<h3 id="参考链接">参考链接</h3>
<p>1.<a href="https://github.com/lgsvl/simulator">https://github.com/lgsvl/simulator</a></p>
<p>2.<a href="https://www.bianchengquan.com/article/219836.html">https://www.bianchengquan.com/article/219836.html</a></p>
<p>3.<a href="https://zhuanlan.zhihu.com/p/398051316">https://zhuanlan.zhihu.com/p/398051316</a></p>
<p>4.<a href="https://arxiv.org/abs/2003.07739">https://arxiv.org/abs/2003.07739</a></p>
<p>5.<a href="https://link.zhihu.com/?target=http%3A//bit.ly/GoM">https://link.zhihu.com/?target=http%3A//bit.ly/GoM</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Raspberry Pico教程]]></title>
        <id>https://zihan987.github.io/post/raspberry-pico-jiao-cheng/</id>
        <link href="https://zihan987.github.io/post/raspberry-pico-jiao-cheng/">
        </link>
        <updated>2021-08-12T05:22:22.000Z</updated>
        <summary type="html"><![CDATA[<p>Pico是树莓派基金协会发布的一款单片机板卡，体积小，用python语言就能开发。Pico的官方教程是英文的，因此阿chai在这里整理一下使用教程以及配套的案例，小伙伴们可以来一起学习。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Pico是树莓派基金协会发布的一款单片机板卡，体积小，用python语言就能开发。Pico的官方教程是英文的，因此阿chai在这里整理一下使用教程以及配套的案例，小伙伴们可以来一起学习。</p>
<!-- more -->
<p>在看教程之前需要下载阿chai提供的Demo：</p>
<p><a href="https://github.com/zihan987/Raspberry-Pi-Pico.git">https://github.com/zihan987/Raspberry-Pi-Pico.git</a></p>
<p>下面是教程目录，小伙伴们根据自己的选择去浏览。</p>
<p>一. 环境搭建与简介</p>
<ul>
<li><a href="https://zihan987.github.io/post/pico-kai-fa-huan-jing-an-zhuang/">Pico开发环境搭建</a></li>
<li><a href="https://zihan987.github.io/post/pico-ying-jian/">Pico硬件资源介绍</a></li>
</ul>
<p>二. 基础篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/io-de-shi-yong/">IO</a></li>
<li><a href="https://zihan987.github.io/post/uart/">UART</a></li>
<li><a href="https://zihan987.github.io/post/zhong-duan-ding-shi-qi/">中断、定时器</a></li>
</ul>
<p>三. 进阶篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/i2c/">I2C</a></li>
<li><a href="https://zihan987.github.io/post/spi/">SPI</a></li>
</ul>
<p>四. 高级篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/adc/">ADC</a></li>
<li><a href="https://zihan987.github.io/post/pwm/">PWM</a></li>
</ul>
<p>五. 案例</p>
<ul>
<li><a href="https://zihan987.github.io/post/ws2812-led/">案例一：WS2812 LED</a></li>
<li><a href="https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/">案例二：姿态传感器</a></li>
<li><a href="https://zihan987.github.io/post/zi-tai-chuan-gan-qi/">案例三：温湿度传感器</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[姿态传感器]]></title>
        <id>https://zihan987.github.io/post/zi-tai-chuan-gan-qi/</id>
        <link href="https://zihan987.github.io/post/zi-tai-chuan-gan-qi/">
        </link>
        <updated>2021-08-12T05:19:23.000Z</updated>
        <summary type="html"><![CDATA[<p>平衡车、手机体感、旋翼无人机的平衡主要靠陀螺模组，MPU9250是一款常用的9轴姿态测量单元。MPU9250有两个内部时钟源，以及一个PLL。</p>
]]></summary>
        <content type="html"><![CDATA[<p>平衡车、手机体感、旋翼无人机的平衡主要靠陀螺模组，MPU9250是一款常用的9轴姿态测量单元。MPU9250有两个内部时钟源，以及一个PLL。</p>
<!-- more -->
<table>
<thead>
<tr>
<th>时钟源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部振荡器</td>
<td>功耗低，但时钟精度略差</td>
</tr>
<tr>
<td>X,Y或Z方向的Gyro</td>
<td>MEMS时钟，功耗较高，但时钟精确（只要Gyro一经启用，就会使用该时钟源）</td>
</tr>
</tbody>
</table>
<p>时钟的选择需要综合平衡 时钟精度和功耗两个因素，所以从MPU9250的性能参数可以看到，一旦Gyro开启，功耗都是在mA级别，而加速度计和磁力计都是在uA级别的功耗。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/MPU9250.jpeg?raw=true" alt="MPU9250.jpeg" loading="lazy"></figure>
<p>电气元件：</p>
<table>
<thead>
<tr>
<th>元器件</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>MPU9250</td>
<td>1</td>
</tr>
<tr>
<td>Raspberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>电气接线图：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/mpu9250_spi_bb.png?raw=true" alt="mpu9250_spi_bb.png" loading="lazy"></figure>
<p>demo：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/spi.h&quot;

#define PIN_MISO 4
#define PIN_CS   5
#define PIN_SCK  6
#define PIN_MOSI 7

#define SPI_PORT spi0
#define READ_BIT 0x80

static inline void cs_select() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 0);  // Active low
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static inline void cs_deselect() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 1);
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static void mpu9250_reset() {
    // Two byte reset. First byte register, second byte data
    // There are a load more options to set up the device in different ways that could be added here
    uint8_t buf[] = {0x6B, 0x00};
    cs_select();
    spi_write_blocking(SPI_PORT, buf, 2);
    cs_deselect();
}


static void read_registers(uint8_t reg, uint8_t *buf, uint16_t len) {

    reg |= READ_BIT;
    cs_select();
    spi_write_blocking(SPI_PORT, &amp;reg, 1);
    sleep_ms(10);
    spi_read_blocking(SPI_PORT, 0, buf, len);
    cs_deselect();
    sleep_ms(10);
}


static void mpu9250_read_raw(int16_t accel[3], int16_t gyro[3], int16_t *temp) {
    uint8_t buffer[6];

    // Start reading acceleration registers from register 0x3B for 6 bytes
    read_registers(0x3B, buffer, 6);

    for (int i = 0; i &lt; 3; i++) {
        accel[i] = (buffer[i * 2] &lt;&lt; 8 | buffer[(i * 2) + 1]);
    }

    // Now gyro data from reg 0x43 for 6 bytes
    read_registers(0x43, buffer, 6);

    for (int i = 0; i &lt; 3; i++) {
        gyro[i] = (buffer[i * 2] &lt;&lt; 8 | buffer[(i * 2) + 1]);;
    }

    // Now temperature from reg 0x41 for 2 bytes
    read_registers(0x41, buffer, 2);

    *temp = buffer[0] &lt;&lt; 8 | buffer[1];
}

int main() {
    stdio_init_all();

    printf(&quot;Hello, MPU9250! Reading raw data from registers via SPI...\n&quot;);

    // This example will use SPI0 at 0.5MHz.
    spi_init(SPI_PORT, 500 * 1000);
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Chip select is active-low, so we'll initialise it to a driven-high state
    gpio_init(PIN_CS);
    gpio_set_dir(PIN_CS, GPIO_OUT);
    gpio_put(PIN_CS, 1);

    mpu9250_reset();

    // See if SPI is working - interrograte the device for its I2C ID number, should be 0x71
    uint8_t id;
    read_registers(0x75, &amp;id, 1);
    printf(&quot;I2C address is 0x%x\n&quot;, id);

    int16_t acceleration[3], gyro[3], temp;

    while (1) {
        mpu9250_read_raw(acceleration, gyro, &amp;temp);

        // These are the raw numbers from the chip, so will need tweaking to be really useful.
        // See the datasheet for more information
        printf(&quot;Acc. X = %d, Y = %d, Z = %d\n&quot;, acceleration[0], acceleration[1], acceleration[2]);
        printf(&quot;Gyro. X = %d, Y = %d, Z = %d\n&quot;, gyro[0], gyro[1], gyro[2]);
        // Temperature is simple so use the datasheet calculation to get deg C.
        // Note this is chip temperature.
        printf(&quot;Temp. = %f\n&quot;, (temp / 340.0) + 36.53);

        sleep_ms(100);
    }

    return 0;
}
</code></pre>
<p>CMakeLists.txt:</p>
<pre><code class="language-cmake">add_executable(mpu9250_spi
        mpu9250_spi.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(mpu9250_spi pico_stdlib hardware_spi)

# create map/bin/hex file etc.
pico_add_extra_outputs(mpu9250_spi)

# add url via pico_set_program_url
example_auto_set_url(mpu9250_spi)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[温湿度传感器]]></title>
        <id>https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/</id>
        <link href="https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/">
        </link>
        <updated>2021-08-12T05:18:27.000Z</updated>
        <summary type="html"><![CDATA[<p>DHT11、DHT21系列的传感器小伙伴们一定很熟悉，单片机一接，写个小的APP，可以做个小型的室内温湿度监测系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>DHT11、DHT21系列的传感器小伙伴们一定很熟悉，单片机一接，写个小的APP，可以做个小型的室内温湿度监测系统。</p>
<!-- more -->
<p>材料清单：</p>
<table>
<thead>
<tr>
<th>元器件名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>DHT11</td>
<td>1</td>
</tr>
<tr>
<td>Respberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>10k电阻</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>电气接线图：</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/pi-and-pico-uart-and-dht-sensor.png?raw=true" alt="pi-and-pico-uart-and-dht-sensor.png" loading="lazy"></figure>
<p>Demo:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/gpio.h&quot;

const uint LED_PIN = PICO_DEFAULT_LED_PIN;
const uint DHT_PIN = 15;
const uint MAX_TIMINGS = 85;

typedef struct {
    float humidity;
    float temp_celsius;
} dht_reading;

void read_from_dht(dht_reading *result);

int main() {
    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_init(DHT_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    while (1) {
        dht_reading reading;
        read_from_dht(&amp;reading);
        float fahrenheit = (reading.temp_celsius * 9 / 5) + 32;
        printf(&quot;Humidity = %.1f%%, Temperature = %.1fC (%.1fF)\n&quot;,
               reading.humidity, reading.temp_celsius, fahrenheit);

        sleep_ms(2000);
    }
}

void read_from_dht(dht_reading *result) {
    int data[5] = {0, 0, 0, 0, 0};
    uint last = 1;
    uint j = 0;

    gpio_set_dir(DHT_PIN, GPIO_OUT);
    gpio_put(DHT_PIN, 0);
    sleep_ms(20);
    gpio_set_dir(DHT_PIN, GPIO_IN);

    gpio_put(LED_PIN, 1);
    for (uint i = 0; i &lt; MAX_TIMINGS; i++) {
        uint count = 0;
        while (gpio_get(DHT_PIN) == last) {
            count++;
            sleep_us(1);
            if (count == 255) break;
        }
        last = gpio_get(DHT_PIN);
        if (count == 255) break;

        if ((i &gt;= 4) &amp;&amp; (i % 2 == 0)) {
            data[j / 8] &lt;&lt;= 1;
            if (count &gt; 16) data[j / 8] |= 1;
            j++;
        }
    }
    gpio_put(LED_PIN, 0);

    if ((j &gt;= 40) &amp;&amp; (data[4] == ((data[0] + data[1] + data[2] + data[3]) &amp; 0xFF))) {
        result-&gt;humidity = (float) ((data[0] &lt;&lt; 8) + data[1]) / 10;
        if (result-&gt;humidity &gt; 100) {
            result-&gt;humidity = data[0];
        }
        result-&gt;temp_celsius = (float) (((data[2] &amp; 0x7F) &lt;&lt; 8) + data[3]) / 10;
        if (result-&gt;temp_celsius &gt; 125) {
            result-&gt;temp_celsius = data[2];
        }
        if (data[2] &amp; 0x80) {
            result-&gt;temp_celsius = -result-&gt;temp_celsius;
        }
    } else {
        printf(&quot;Bad data\n&quot;);
    }
}
</code></pre>
<p>CMakelist.txt:</p>
<pre><code class="language-cmake">add_executable(dht
        dht.c
        )

target_link_libraries(dht pico_stdlib)

pico_add_extra_outputs(dht)

# add url via pico_set_program_url
example_auto_set_url(dht)
</code></pre>
<p>终端的输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/DHT1.jpg?raw=true" alt="DHT1.jpg" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WS2812 LED]]></title>
        <id>https://zihan987.github.io/post/ws2812-led/</id>
        <link href="https://zihan987.github.io/post/ws2812-led/">
        </link>
        <updated>2021-08-12T05:17:50.000Z</updated>
        <summary type="html"><![CDATA[<p>WS2812 LED是一种全彩的LED，我们平时看到的很多彩灯以及点阵就是这样的，因此第一个实践案例用来做这个真的不错。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WS2812 LED是一种全彩的LED，我们平时看到的很多彩灯以及点阵就是这样的，因此第一个实践案例用来做这个真的不错。</p>
<!-- more -->
<p>电气接线图：</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/WSB2.png?raw=true" alt="WSB2.png" loading="lazy"></figure>
<p>材料清单：</p>
<table>
<thead>
<tr>
<th>元器件</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raspberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>WS2812 LED</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>demo程序：</p>
<pre><code class="language-python">import array, time
from machine import Pin
import rp2

# Configure the number of WS2812 LEDs.
NUM_LEDS = 16
PIN_NUM = 6
brightness = 0.2

@rp2.asm_pio(sideset_init=rp2.PIO.OUT_LOW, out_shiftdir=rp2.PIO.SHIFT_LEFT, autopull=True, pull_thresh=24)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label(&quot;bitloop&quot;)
    out(x, 1)               .side(0)    [T3 - 1]
    jmp(not_x, &quot;do_zero&quot;)   .side(1)    [T1 - 1]
    jmp(&quot;bitloop&quot;)          .side(1)    [T2 - 1]
    label(&quot;do_zero&quot;)
    nop()                   .side(0)    [T2 - 1]
    wrap()


# Create the StateMachine with the ws2812 program, outputting on pin
sm = rp2.StateMachine(0, ws2812, freq=8_000_000, sideset_base=Pin(PIN_NUM))

# Start the StateMachine, it will wait for data on its FIFO.
sm.active(1)

# Display a pattern on the LEDs via an array of LED RGB values.
ar = array.array(&quot;I&quot;, [0 for _ in range(NUM_LEDS)])

##########################################################################
def pixels_show():
    dimmer_ar = array.array(&quot;I&quot;, [0 for _ in range(NUM_LEDS)])
    for i,c in enumerate(ar):
        r = int(((c &gt;&gt; 8) &amp; 0xFF) * brightness)
        g = int(((c &gt;&gt; 16) &amp; 0xFF) * brightness)
        b = int((c &amp; 0xFF) * brightness)
        dimmer_ar[i] = (g&lt;&lt;16) + (r&lt;&lt;8) + b
    sm.put(dimmer_ar, 8)
    time.sleep_ms(10)

def pixels_set(i, color):
    ar[i] = (color[1]&lt;&lt;16) + (color[0]&lt;&lt;8) + color[2]

def pixels_fill(color):
    for i in range(len(ar)):
        pixels_set(i, color)

def color_chase(color, wait):
    for i in range(NUM_LEDS):
        pixels_set(i, color)
        time.sleep(wait)
        pixels_show()
    time.sleep(0.2)
 
def wheel(pos):
    # Input a value 0 to 255 to get a color value.
    # The colours are a transition r - g - b - back to r.
    if pos &lt; 0 or pos &gt; 255:
        return (0, 0, 0)
    if pos &lt; 85:
        return (255 - pos * 3, pos * 3, 0)
    if pos &lt; 170:
        pos -= 85
        return (0, 255 - pos * 3, pos * 3)
    pos -= 170
    return (pos * 3, 0, 255 - pos * 3)
 
 
def rainbow_cycle(wait):
    for j in range(255):
        for i in range(NUM_LEDS):
            rc_index = (i * 256 // NUM_LEDS) + j
            pixels_set(i, wheel(rc_index &amp; 255))
        pixels_show()
        time.sleep(wait)

BLACK = (0, 0, 0)
RED = (255, 0, 0)
YELLOW = (255, 150, 0)
GREEN = (0, 255, 0)
CYAN = (0, 255, 255)
BLUE = (0, 0, 255)
PURPLE = (180, 0, 255)
WHITE = (255, 255, 255)
COLORS = (BLACK, RED, YELLOW, GREEN, CYAN, BLUE, PURPLE, WHITE)

print(&quot;fills&quot;)
for color in COLORS:       
    pixels_fill(color)
    pixels_show()
    time.sleep(0.2)

print(&quot;chases&quot;)
for color in COLORS:       
    color_chase(color, 0.01)

print(&quot;rainbow&quot;)
rainbow_cycle(0)
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/wsb1.png?raw=true" alt="wsb1.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PWM]]></title>
        <id>https://zihan987.github.io/post/pwm/</id>
        <link href="https://zihan987.github.io/post/pwm/">
        </link>
        <updated>2021-08-12T05:16:26.000Z</updated>
        <summary type="html"><![CDATA[<p>脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。</p>
]]></summary>
        <content type="html"><![CDATA[<p>脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">import time
from machine import Pin, PWM


# Construct PWM object, with LED on Pin(25).
pwm = PWM(Pin(25))

# Set the PWM frequency.
pwm.freq(1000)

# Fade the LED in and out a few times.
duty = 0
direction = 1
for _ in range(8 * 256):
    duty += direction
    if duty &gt; 255:
        duty = 255
        direction = -1
    elif duty &lt; 0:
        duty = 0
        direction = 1
    pwm.duty_u16(duty * duty)
    time.sleep(0.001)
</code></pre>
<h3 id="cc">C/C++</h3>
<p>以呼吸灯为例，LED为核心板上的。</p>
<pre><code class="language-c">#include &quot;pico/stdlib.h&quot;
#include &lt;stdio.h&gt;
#include &quot;pico/time.h&quot;
#include &quot;hardware/irq.h&quot;
#include &quot;hardware/pwm.h&quot;

void on_pwm_wrap() {
    static int fade = 0;
    static bool going_up = true;
    // Clear the interrupt flag that brought us here
    pwm_clear_irq(pwm_gpio_to_slice_num(PICO_DEFAULT_LED_PIN));

    if (going_up) {
        ++fade;
        if (fade &gt; 255) {
            fade = 255;
            going_up = false;
        }
    } else {
        --fade;
        if (fade &lt; 0) {
            fade = 0;
            going_up = true;
        }
    }
    // Square the fade value to make the LED's brightness appear more linear
    // Note this range matches with the wrap value
    pwm_set_gpio_level(PICO_DEFAULT_LED_PIN, fade * fade);
}

int main() {
    // Tell the LED pin that the PWM is in charge of its value.
    gpio_set_function(PICO_DEFAULT_LED_PIN, GPIO_FUNC_PWM);
    // Figure out which slice we just connected to the LED pin
    uint slice_num = pwm_gpio_to_slice_num(PICO_DEFAULT_LED_PIN);

    pwm_clear_irq(slice_num);
    pwm_set_irq_enabled(slice_num, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    // counter is allowed to wrap over its maximum range (0 to 2**16-1)
    pwm_config config = pwm_get_default_config();
    // Set divider, reduces counter clock to sysclock/this value
    pwm_config_set_clkdiv(&amp;config, 4.f);
    // Load the configuration into our PWM slice, and set it running.
    pwm_init(slice_num, &amp;config, true);

    while (1)
        tight_loop_contents();
}

</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(pwm_led_fade
        pwm_led_fade.c
        )

# Pull in our pico_stdlib which pulls in commonly used features
target_link_libraries(pwm_led_fade pico_stdlib hardware_pwm)

# create map/bin/hex file etc.
pico_add_extra_outputs(pwm_led_fade)

# add url via pico_set_program_url
example_auto_set_url(pwm_led_fade)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ADC]]></title>
        <id>https://zihan987.github.io/post/adc/</id>
        <link href="https://zihan987.github.io/post/adc/">
        </link>
        <updated>2021-08-12T05:15:36.000Z</updated>
        <summary type="html"><![CDATA[<p>模拟数字转换器即A/D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。通常的模数转换器是将一个输入电压信号转换为一个输出的数字信号。</p>
]]></summary>
        <content type="html"><![CDATA[<p>模拟数字转换器即A/D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。通常的模数转换器是将一个输入电压信号转换为一个输出的数字信号。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">import machine
import utime

sensor_temp = machine.ADC(4)
conversion_factor = 3.3 / (65535)

while True:
    reading = sensor_temp.read_u16() * conversion_factor
    
    # The temperature sensor measures the Vbe voltage of a biased bipolar diode, connected to the fifth ADC channel
    # Typically, Vbe = 0.706V at 27 degrees C, with a slope of -1.721mV (0.001721) per degree. 
    temperature = 27 - (reading - 0.706)/0.001721
    print(temperature)
    utime.sleep(2)
</code></pre>
<h3 id="cc">C/C++</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/adc.h&quot;  // For ADC input:
#include &quot;hardware/dma.h&quot;

#include &quot;pico/multicore.h&quot;// For resistor DAC output:
#include &quot;hardware/pio.h&quot;
#include &quot;resistor_dac.pio.h&quot;

// Channel 0 is GPIO26
#define CAPTURE_CHANNEL 0
#define CAPTURE_DEPTH 1000

uint8_t capture_buf[CAPTURE_DEPTH];

void core1_main();

int main() {
    stdio_init_all();

    // Send core 1 off to start driving the &quot;DAC&quot; whilst we configure the ADC.
    multicore_launch_core1(core1_main);

    // Init GPIO for analogue use: hi-Z, no pulls, disable digital input buffer.
    adc_gpio_init(26 + CAPTURE_CHANNEL);

    adc_init();
    adc_select_input(CAPTURE_CHANNEL);
    adc_fifo_setup(
        true,    // Write each completed conversion to the sample FIFO
        true,    // Enable DMA data request (DREQ)
        1,       // DREQ (and IRQ) asserted when at least 1 sample present
        false,   // We won't see the ERR bit because of 8 bit reads; disable.
        true     // Shift each sample to 8 bits when pushing to FIFO
    );

    adc_set_clkdiv(0);

    printf(&quot;Arming DMA\n&quot;);
    sleep_ms(1000);
    // Set up the DMA to start transferring data as soon as it appears in FIFO
    uint dma_chan = dma_claim_unused_channel(true);
    dma_channel_config cfg = dma_channel_get_default_config(dma_chan);

    // Reading from constant address, writing to incrementing byte addresses
    channel_config_set_transfer_data_size(&amp;cfg, DMA_SIZE_8);
    channel_config_set_read_increment(&amp;cfg, false);
    channel_config_set_write_increment(&amp;cfg, true);

    // Pace transfers based on availability of ADC samples
    channel_config_set_dreq(&amp;cfg, DREQ_ADC);

    dma_channel_configure(dma_chan, &amp;cfg,
        capture_buf,    // dst
        &amp;adc_hw-&gt;fifo,  // src
        CAPTURE_DEPTH,  // transfer count
        true            // start immediately
    );

    printf(&quot;Starting capture\n&quot;);
    adc_run(true);

    // Once DMA finishes, stop any new conversions from starting, and clean up
    // the FIFO in case the ADC was still mid-conversion.
    dma_channel_wait_for_finish_blocking(dma_chan);
    printf(&quot;Capture finished\n&quot;);
    adc_run(false);
    adc_fifo_drain();

    // Print samples to stdout so you can display them in pyplot, excel, matlab
    for (int i = 0; i &lt; CAPTURE_DEPTH; ++i) {
        printf(&quot;%-3d, &quot;, capture_buf[i]);
        if (i % 10 == 9)
            printf(&quot;\n&quot;);
    }
}

#define OUTPUT_FREQ_KHZ 5
#define SAMPLE_WIDTH 5
// This is the green channel on the VGA board
#define DAC_PIN_BASE 6

void core1_main() {
    PIO pio = pio0;
    uint sm = pio_claim_unused_sm(pio0, true);
    uint offset = pio_add_program(pio0, &amp;resistor_dac_5bit_program);
    resistor_dac_5bit_program_init(pio0, sm, offset,
        OUTPUT_FREQ_KHZ * 1000 * 2 * (1 &lt;&lt; SAMPLE_WIDTH), DAC_PIN_BASE);
    while (true) {
        // Triangle wave
        for (int i = 0; i &lt; (1 &lt;&lt; SAMPLE_WIDTH); ++i)
            pio_sm_put_blocking(pio, sm, i);
        for (int i = 0; i &lt; (1 &lt;&lt; SAMPLE_WIDTH); ++i)
            pio_sm_put_blocking(pio, sm, (1 &lt;&lt; SAMPLE_WIDTH) - 1 - i);
    }
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(adc_dma_capture
        dma_capture.c
        )

pico_generate_pio_header(adc_dma_capture ${CMAKE_CURRENT_LIST_DIR}/resistor_dac.pio)

target_link_libraries(adc_dma_capture
		pico_stdlib
		hardware_adc
		hardware_dma
		# For the dummy output:
		hardware_pio
		pico_multicore
		)

# create map/bin/hex file etc.
pico_add_extra_outputs(adc_dma_capture)

# add url via pico_set_program_url
example_auto_set_url(adc_dma_capture)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SPI]]></title>
        <id>https://zihan987.github.io/post/spi/</id>
        <link href="https://zihan987.github.io/post/spi/">
        </link>
        <updated>2021-08-12T05:13:41.000Z</updated>
        <summary type="html"><![CDATA[<p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。主要应用在EEPROM、Flash、实时时钟(RTC)、数模转换器(ADC)、网络控制器、MCU、数字信号处理器(DSP)以及数字信号解码器之间。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。主要应用在EEPROM、Flash、实时时钟(RTC)、数模转换器(ADC)、网络控制器、MCU、数字信号处理器(DSP)以及数字信号解码器之间。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">from machine import SPI

spi = SPI(0)
spi = SPI(0, 100_000)
spi = SPI(0, 100_000, polarity=1, phase=1)

spi.write('test')
spi.read(5)

buf = bytearray(3)
spi.write_readinto('out', buf)
</code></pre>
<h3 id="cc">C/C++</h3>
<p>以bme280温度压力传感器为例。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/bme280_spi_bb.png?raw=true" alt="bme280_spi_bb.png" loading="lazy"></figure>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/spi.h&quot;

#define PIN_MISO 16
#define PIN_CS   17
#define PIN_SCK  18
#define PIN_MOSI 19

#define SPI_PORT spi0
#define READ_BIT 0x80

int32_t t_fine;

uint16_t dig_T1;
int16_t dig_T2, dig_T3;
uint16_t dig_P1;
int16_t dig_P2, dig_P3, dig_P4, dig_P5, dig_P6, dig_P7, dig_P8, dig_P9;
uint8_t dig_H1, dig_H3;
int8_t dig_H6;
int16_t dig_H2, dig_H4, dig_H5;

/* The following compensation functions are required to convert from the raw ADC
data from the chip to something usable. Each chip has a different set of
compensation parameters stored on the chip at point of manufacture, which are
read from the chip at startup and used inthese routines.
*/
int32_t compensate_temp(int32_t adc_T) {
    int32_t var1, var2, T;
    var1 = ((((adc_T &gt;&gt; 3) - ((int32_t) dig_T1 &lt;&lt; 1))) * ((int32_t) dig_T2)) &gt;&gt; 11;
    var2 = (((((adc_T &gt;&gt; 4) - ((int32_t) dig_T1)) * ((adc_T &gt;&gt; 4) - ((int32_t) dig_T1))) &gt;&gt; 12) * ((int32_t) dig_T3))
            &gt;&gt; 14;

    t_fine = var1 + var2;
    T = (t_fine * 5 + 128) &gt;&gt; 8;
    return T;
}

uint32_t compensate_pressure(int32_t adc_P) {
    int32_t var1, var2;
    uint32_t p;
    var1 = (((int32_t) t_fine) &gt;&gt; 1) - (int32_t) 64000;
    var2 = (((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 11) * ((int32_t) dig_P6);
    var2 = var2 + ((var1 * ((int32_t) dig_P5)) &lt;&lt; 1);
    var2 = (var2 &gt;&gt; 2) + (((int32_t) dig_P4) &lt;&lt; 16);
    var1 = (((dig_P3 * (((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 13)) &gt;&gt; 3) + ((((int32_t) dig_P2) * var1) &gt;&gt; 1)) &gt;&gt; 18;
    var1 = ((((32768 + var1)) * ((int32_t) dig_P1)) &gt;&gt; 15);
    if (var1 == 0)
        return 0;

    p = (((uint32_t) (((int32_t) 1048576) - adc_P) - (var2 &gt;&gt; 12))) * 3125;
    if (p &lt; 0x80000000)
        p = (p &lt;&lt; 1) / ((uint32_t) var1);
    else
        p = (p / (uint32_t) var1) * 2;

    var1 = (((int32_t) dig_P9) * ((int32_t) (((p &gt;&gt; 3) * (p &gt;&gt; 3)) &gt;&gt; 13))) &gt;&gt; 12;
    var2 = (((int32_t) (p &gt;&gt; 2)) * ((int32_t) dig_P8)) &gt;&gt; 13;
    p = (uint32_t) ((int32_t) p + ((var1 + var2 + dig_P7) &gt;&gt; 4));

    return p;
}

uint32_t compensate_humidity(int32_t adc_H) {
    int32_t v_x1_u32r;
    v_x1_u32r = (t_fine - ((int32_t) 76800));
    v_x1_u32r = (((((adc_H &lt;&lt; 14) - (((int32_t) dig_H4) &lt;&lt; 20) - (((int32_t) dig_H5) * v_x1_u32r)) +
                   ((int32_t) 16384)) &gt;&gt; 15) * (((((((v_x1_u32r * ((int32_t) dig_H6)) &gt;&gt; 10) * (((v_x1_u32r *
                                                                                                  ((int32_t) dig_H3))
            &gt;&gt; 11) + ((int32_t) 32768))) &gt;&gt; 10) + ((int32_t) 2097152)) *
                                                 ((int32_t) dig_H2) + 8192) &gt;&gt; 14));
    v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r &gt;&gt; 15) * (v_x1_u32r &gt;&gt; 15)) &gt;&gt; 7) * ((int32_t) dig_H1)) &gt;&gt; 4));
    v_x1_u32r = (v_x1_u32r &lt; 0 ? 0 : v_x1_u32r);
    v_x1_u32r = (v_x1_u32r &gt; 419430400 ? 419430400 : v_x1_u32r);

    return (uint32_t) (v_x1_u32r &gt;&gt; 12);
}

static inline void cs_select() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 0);  // Active low
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static inline void cs_deselect() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 1);
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static void write_register(uint8_t reg, uint8_t data) {
    uint8_t buf[2];
    buf[0] = reg &amp; 0x7f;  // remove read bit as this is a write
    buf[1] = data;
    cs_select();
    spi_write_blocking(SPI_PORT, buf, 2);
    cs_deselect();
    sleep_ms(10);
}

static void read_registers(uint8_t reg, uint8_t *buf, uint16_t len) {
    // For this particular device, we send the device the register we want to read
    // first, then subsequently read from the device. The register is auto incrementing
    // so we don't need to keep sending the register we want, just the first.
    reg |= READ_BIT;
    cs_select();
    spi_write_blocking(SPI_PORT, &amp;reg, 1);
    sleep_ms(10);
    spi_read_blocking(SPI_PORT, 0, buf, len);
    cs_deselect();
    sleep_ms(10);
}

/* This function reads the manufacturing assigned compensation parameters from the device */
void read_compensation_parameters() {
    uint8_t buffer[26];

    read_registers(0x88, buffer, 24);

    dig_T1 = buffer[0] | (buffer[1] &lt;&lt; 8);
    dig_T2 = buffer[2] | (buffer[3] &lt;&lt; 8);
    dig_T3 = buffer[4] | (buffer[5] &lt;&lt; 8);

    dig_P1 = buffer[6] | (buffer[7] &lt;&lt; 8);
    dig_P2 = buffer[8] | (buffer[9] &lt;&lt; 8);
    dig_P3 = buffer[10] | (buffer[11] &lt;&lt; 8);
    dig_P4 = buffer[12] | (buffer[13] &lt;&lt; 8);
    dig_P5 = buffer[14] | (buffer[15] &lt;&lt; 8);
    dig_P6 = buffer[16] | (buffer[17] &lt;&lt; 8);
    dig_P7 = buffer[18] | (buffer[19] &lt;&lt; 8);
    dig_P8 = buffer[20] | (buffer[21] &lt;&lt; 8);
    dig_P9 = buffer[22] | (buffer[23] &lt;&lt; 8);

    dig_H1 = buffer[25];

    read_registers(0xE1, buffer, 8);

    dig_H2 = buffer[0] | (buffer[1] &lt;&lt; 8);
    dig_H3 = (int8_t) buffer[2];
    dig_H4 = buffer[3] &lt;&lt; 4 | (buffer[4] &amp; 0xf);
    dig_H5 = (buffer[5] &gt;&gt; 4) | (buffer[6] &lt;&lt; 4);
    dig_H6 = (int8_t) buffer[7];
}

static void bme280_read_raw(int32_t *humidity, int32_t *pressure, int32_t *temperature) {
    uint8_t buffer[8];

    read_registers(0xF7, buffer, 8);
    *pressure = ((uint32_t) buffer[0] &lt;&lt; 12) | ((uint32_t) buffer[1] &lt;&lt; 4) | (buffer[2] &gt;&gt; 4);
    *temperature = ((uint32_t) buffer[3] &lt;&lt; 12) | ((uint32_t) buffer[4] &lt;&lt; 4) | (buffer[5] &gt;&gt; 4);
    *humidity = (uint32_t) buffer[6] &lt;&lt; 8 | buffer[7];
}

int main() {
    stdio_init_all();

    printf(&quot;Hello, bme280! Reading raw data from registers via SPI...\n&quot;);

    // This example will use SPI0 at 0.5MHz.
    spi_init(SPI_PORT, 500 * 1000);
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Chip select is active-low, so we'll initialise it to a driven-high state
    gpio_init(PIN_CS);
    gpio_set_dir(PIN_CS, GPIO_OUT);
    gpio_put(PIN_CS, 1);

    // See if SPI is working - interrograte the device for its I2C ID number, should be 0x60
    uint8_t id;
    read_registers(0xD0, &amp;id, 1);
    printf(&quot;Chip ID is 0x%x\n&quot;, id);

    read_compensation_parameters();

    write_register(0xF2, 0x1); // Humidity oversampling register - going for x1
    write_register(0xF4, 0x27);// Set rest of oversampling modes and run mode to normal

    int32_t humidity, pressure, temperature;

    while (1) {
        bme280_read_raw(&amp;humidity, &amp;pressure, &amp;temperature);

        // These are the raw numbers from the chip, so we need to run through the
        // compensations to get human understandable numbers
        pressure = compensate_pressure(pressure);
        temperature = compensate_temp(temperature);
        humidity = compensate_humidity(humidity);

        printf(&quot;Humidity = %.2f%%\n&quot;, humidity / 1024.0);
        printf(&quot;Pressure = %dPa\n&quot;, pressure);
        printf(&quot;Temp. = %.2fC\n&quot;, temperature / 100.0);

        sleep_ms(1000);
    }

    return 0;
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(bme280_spi
        bme280_spi.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(bme280_spi pico_stdlib hardware_spi)

# create map/bin/hex file etc.
pico_add_extra_outputs(bme280_spi)

# add url via pico_set_program_url
example_auto_set_url(bme280_spi)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[I2C]]></title>
        <id>https://zihan987.github.io/post/i2c/</id>
        <link href="https://zihan987.github.io/post/i2c/">
        </link>
        <updated>2021-08-12T05:11:12.000Z</updated>
        <summary type="html"><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。<a href="https://baike.baidu.com/item/SDA">SDA</a>(串行数据线)和<a href="https://baike.baidu.com/item/SCL">SCL</a>(串行时钟线)都是双向I/O线，接口电路为<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA">开漏输出</a>。需通过<a href="https://baike.baidu.com/item/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB">上拉电阻</a>接电源VCC．当总线空闲时。两根线都是<a href="https://baike.baidu.com/item/%E9%AB%98%E7%94%B5%E5%B9%B3">高电平</a>，连接总线的外同器件都是<a href="https://baike.baidu.com/item/CMOS">CMOS</a>器件，输出级也是开漏电路。</p>
]]></summary>
        <content type="html"><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。<a href="https://baike.baidu.com/item/SDA">SDA</a>(串行数据线)和<a href="https://baike.baidu.com/item/SCL">SCL</a>(串行时钟线)都是双向I/O线，接口电路为<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA">开漏输出</a>。需通过<a href="https://baike.baidu.com/item/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB">上拉电阻</a>接电源VCC．当总线空闲时。两根线都是<a href="https://baike.baidu.com/item/%E9%AB%98%E7%94%B5%E5%B9%B3">高电平</a>，连接总线的外同器件都是<a href="https://baike.baidu.com/item/CMOS">CMOS</a>器件，输出级也是开漏电路。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<p>我们以OLED屏幕的通信为例。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/pico-and-oled.png?raw=true" alt="pico-and-oled.png" loading="lazy"></figure>
<pre><code class="language-python">from machine import I2C, ADC
from sh1106 import SH1106_I2C
import framebuf


WIDTH  = 128                                            # oled display width
HEIGHT = 128                                            # oled display height

i2c = I2C(0)                                            # Init I2C using I2C0 defaults, SCL=Pin(GP9), SDA=Pin(GP8), freq=400000
print(&quot;I2C Address      : &quot;+hex(i2c.scan()[0]).upper()) # Display device address
print(&quot;I2C Configuration: &quot;+str(i2c))                   # Display I2C config


oled = SH1106_I2C(WIDTH, HEIGHT, i2c)                  # Init oled display

# Raspberry Pi logo as 32x32 bytearray
buffer = bytearray(b&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00|?\x00\x01\x86@\x80\x01\x01\x80\x80\x01\x11\x88\x80\x01\x05\xa0\x80\x00\x83\xc1\x00\x00C\xe3\x00\x00~\xfc\x00\x00L'\x00\x00\x9c\x11\x00\x00\xbf\xfd\x00\x00\xe1\x87\x00\x01\xc1\x83\x80\x02A\x82@\x02A\x82@\x02\xc1\xc2@\x02\xf6&gt;\xc0\x01\xfc=\x80\x01\x18\x18\x80\x01\x88\x10\x80\x00\x8c!\x00\x00\x87\xf1\x00\x00\x7f\xf6\x00\x008\x1c\x00\x00\x0c \x00\x00\x03\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;)

# Load the raspberry pi logo into the framebuffer (the image is 32x32)
fb = framebuf.FrameBuffer(buffer, 32, 32, framebuf.MONO_HLSB)

# Clear the oled display in case it has junk on it.
oled.fill(0)

# Blit the image from the framebuffer to the oled display
oled.blit(fb, 96, 0)

# Add some text
oled.text(&quot;Raspberry Pi&quot;,5,5)
oled.text(&quot;Pico&quot;,5,15)

# Finally update the oled display so the image &amp; text is displayed
oled.show()
</code></pre>
<h3 id="cc">C/C++</h3>
<p>我们以LCD1602为例。</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/lcd_1602_i2c_bb.png?raw=true" alt="lcd_1602_i2c_bb.png" loading="lazy"></figure>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/i2c.h&quot;
#include &quot;pico/binary_info.h&quot;

/* Example code to drive a 16x2 LCD panel via a I2C bridge chip (e.g. PCF8574)
   NOTE: The panel must be capable of being driven at 3.3v NOT 5v. The Pico
   GPIO (and therefor I2C) cannot be used at 5v.
   You will need to use a level shifter on the I2C lines if you want to run the
   board at 5v.
   Connections on Raspberry Pi Pico board, other boards may vary.
   GPIO 4 (pin 6)-&gt; SDA on LCD bridge board
   GPIO 5 (pin 7)-&gt; SCL on LCD bridge board
   3.3v (pin 36) -&gt; VCC on LCD bridge board
   GND (pin 38)  -&gt; GND on LCD bridge board
*/
// commands
const int LCD_CLEARDISPLAY = 0x01;
const int LCD_RETURNHOME = 0x02;
const int LCD_ENTRYMODESET = 0x04;
const int LCD_DISPLAYCONTROL = 0x08;
const int LCD_CURSORSHIFT = 0x10;
const int LCD_FUNCTIONSET = 0x20;
const int LCD_SETCGRAMADDR = 0x40;
const int LCD_SETDDRAMADDR = 0x80;

// flags for display entry mode
const int LCD_ENTRYSHIFTINCREMENT = 0x01;
const int LCD_ENTRYLEFT = 0x02;

// flags for display and cursor control
const int LCD_BLINKON = 0x01;
const int LCD_CURSORON = 0x02;
const int LCD_DISPLAYON = 0x04;

// flags for display and cursor shift
const int LCD_MOVERIGHT = 0x04;
const int LCD_DISPLAYMOVE = 0x08;

// flags for function set
const int LCD_5x10DOTS = 0x04;
const int LCD_2LINE = 0x08;
const int LCD_8BITMODE = 0x10;

// flag for backlight control
const int LCD_BACKLIGHT = 0x08;

const int LCD_ENABLE_BIT = 0x04;

#define I2C_PORT i2c0
// By default these LCD display drivers are on bus address 0x27
static int addr = 0x27;

// Modes for lcd_send_byte
#define LCD_CHARACTER  1
#define LCD_COMMAND    0

#define MAX_LINES      2
#define MAX_CHARS      16

/* Quick helper function for single byte transfers */
void i2c_write_byte(uint8_t val) {
    i2c_write_blocking(I2C_PORT, addr, &amp;val, 1, false);
}

void lcd_toggle_enable(uint8_t val) {
    // Toggle enable pin on LCD display
    // We cannot do this too quickly or things don't work
#define DELAY_US 600
    sleep_us(DELAY_US);
    i2c_write_byte(val | LCD_ENABLE_BIT);
    sleep_us(DELAY_US);
    i2c_write_byte(val &amp; ~LCD_ENABLE_BIT);
    sleep_us(DELAY_US);
}

// The display is sent a byte as two separate nibble transfers
void lcd_send_byte(uint8_t val, int mode) {
    uint8_t high = mode | (val &amp; 0xF0) | LCD_BACKLIGHT;
    uint8_t low = mode | ((val &lt;&lt; 4) &amp; 0xF0) | LCD_BACKLIGHT;

    i2c_write_byte(high);
    lcd_toggle_enable(high);
    i2c_write_byte(low);
    lcd_toggle_enable(low);
}

void lcd_clear(void) {
    lcd_send_byte(LCD_CLEARDISPLAY, LCD_COMMAND);
}

// go to location on LCD
void lcd_set_cursor(int line, int position) {
    int val = (line == 0) ? 0x80 + position : 0xC0 + position;
    lcd_send_byte(val, LCD_COMMAND);
}

static void inline lcd_char(char val) {
    lcd_send_byte(val, LCD_CHARACTER);
}

void lcd_string(const char *s) {
    while (*s) {
        lcd_char(*s++);
    }
}

void lcd_init() {
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x02, LCD_COMMAND);

    lcd_send_byte(LCD_ENTRYMODESET | LCD_ENTRYLEFT, LCD_COMMAND);
    lcd_send_byte(LCD_FUNCTIONSET | LCD_2LINE, LCD_COMMAND);
    lcd_send_byte(LCD_DISPLAYCONTROL | LCD_DISPLAYON, LCD_COMMAND);
    lcd_clear();
}

int main() {
    // This example will use I2C0 on GPIO4 (SDA) and GPIO5 (SCL)
    i2c_init(I2C_PORT, 100 * 1000);
    gpio_set_function(4, GPIO_FUNC_I2C);
    gpio_set_function(5, GPIO_FUNC_I2C);
    gpio_pull_up(4);
    gpio_pull_up(5);
    // Make the I2C pins available to picotool
    bi_decl( bi_2pins_with_func(4, 5, GPIO_FUNC_I2C));

    lcd_init();

    static uint8_t *message[] =
            {
                    &quot;RP2040 by&quot;, &quot;Raspberry Pi&quot;,
                    &quot;A brand new&quot;, &quot;microcontroller&quot;,
                    &quot;Twin core M0&quot;, &quot;Full C SDK&quot;,
                    &quot;More power in&quot;, &quot;your product&quot;,
                    &quot;More beans&quot;, &quot;than Heinz!&quot;
            };

    while (1) {
        for (int m = 0; m &lt; sizeof(message) / sizeof(message[0]); m += MAX_LINES) {
            for (int line = 0; line &lt; MAX_LINES; line++) {
                lcd_set_cursor(line, (MAX_CHARS / 2) - strlen(message[m + line]) / 2);
                lcd_string(message[m + line]);
            }
            sleep_ms(2000);
            lcd_clear();
        }
    }

    return 0;
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">  
add_executable(lcd_1602_i2c
        lcd_1602_i2c.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(lcd_1602_i2c pico_stdlib hardware_i2c)

# create map/bin/hex file etc.
pico_add_extra_outputs(lcd_1602_i2c)

# add url via pico_set_program_url
example_auto_set_url(lcd_1602_i2c)
</code></pre>
]]></content>
    </entry>
</feed>