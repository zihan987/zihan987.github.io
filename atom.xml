<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zihan987.github.io</id>
    <title>阿chai带你学AI</title>
    <updated>2021-08-12T06:07:19.268Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zihan987.github.io"/>
    <link rel="self" href="https://zihan987.github.io/atom.xml"/>
    <subtitle>让我们一起chai哩chai气</subtitle>
    <logo>https://zihan987.github.io/images/avatar.png</logo>
    <icon>https://zihan987.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 阿chai带你学AI</rights>
    <entry>
        <title type="html"><![CDATA[Raspberry Pico教程]]></title>
        <id>https://zihan987.github.io/post/raspberry-pico-jiao-cheng/</id>
        <link href="https://zihan987.github.io/post/raspberry-pico-jiao-cheng/">
        </link>
        <updated>2021-08-12T05:22:22.000Z</updated>
        <summary type="html"><![CDATA[<p>Pico是树莓派基金协会发布的一款单片机板卡，体积小，用python语言就能开发。Pico的官方教程是英文的，因此阿chai在这里整理一下使用教程以及配套的案例，小伙伴们可以来一起学习。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Pico是树莓派基金协会发布的一款单片机板卡，体积小，用python语言就能开发。Pico的官方教程是英文的，因此阿chai在这里整理一下使用教程以及配套的案例，小伙伴们可以来一起学习。</p>
<!-- more -->
<p>在看教程之前需要下载阿chai提供的Demo：</p>
<p><a href="https://github.com/zihan987/Raspberry-Pi-Pico.git">https://github.com/zihan987/Raspberry-Pi-Pico.git</a></p>
<p>下面是教程目录，小伙伴们根据自己的选择去浏览。</p>
<p>一. 环境搭建与简介</p>
<ul>
<li><a href="https://zihan987.github.io/post/pico-kai-fa-huan-jing-an-zhuang/">Pico开发环境搭建</a></li>
<li><a href="https://zihan987.github.io/post/pico-ying-jian/">Pico硬件资源介绍</a></li>
</ul>
<p>二. 基础篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/io-de-shi-yong/">IO</a></li>
<li><a href="https://zihan987.github.io/post/uart/">UART</a></li>
<li><a href="https://zihan987.github.io/post/zhong-duan-ding-shi-qi/">中断、定时器</a></li>
</ul>
<p>三. 进阶篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/i2c/">I2C</a></li>
<li><a href="https://zihan987.github.io/post/spi/">SPI</a></li>
</ul>
<p>四. 高级篇</p>
<ul>
<li><a href="https://zihan987.github.io/post/adc/">ADC</a></li>
<li><a href="https://zihan987.github.io/post/pwm/">PWM</a></li>
</ul>
<p>五. 案例</p>
<ul>
<li><a href="https://zihan987.github.io/post/ws2812-led/">案例一：WS2812 LED</a></li>
<li><a href="https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/">案例二：姿态传感器</a></li>
<li><a href="https://zihan987.github.io/post/zi-tai-chuan-gan-qi/">案例三：温湿度传感器</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[姿态传感器]]></title>
        <id>https://zihan987.github.io/post/zi-tai-chuan-gan-qi/</id>
        <link href="https://zihan987.github.io/post/zi-tai-chuan-gan-qi/">
        </link>
        <updated>2021-08-12T05:19:23.000Z</updated>
        <summary type="html"><![CDATA[<p>平衡车、手机体感、旋翼无人机的平衡主要靠陀螺模组，MPU9250是一款常用的9轴姿态测量单元。MPU9250有两个内部时钟源，以及一个PLL。</p>
]]></summary>
        <content type="html"><![CDATA[<p>平衡车、手机体感、旋翼无人机的平衡主要靠陀螺模组，MPU9250是一款常用的9轴姿态测量单元。MPU9250有两个内部时钟源，以及一个PLL。</p>
<!-- more -->
<table>
<thead>
<tr>
<th>时钟源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部振荡器</td>
<td>功耗低，但时钟精度略差</td>
</tr>
<tr>
<td>X,Y或Z方向的Gyro</td>
<td>MEMS时钟，功耗较高，但时钟精确（只要Gyro一经启用，就会使用该时钟源）</td>
</tr>
</tbody>
</table>
<p>时钟的选择需要综合平衡 时钟精度和功耗两个因素，所以从MPU9250的性能参数可以看到，一旦Gyro开启，功耗都是在mA级别，而加速度计和磁力计都是在uA级别的功耗。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/MPU9250.jpeg?raw=true" alt="MPU9250.jpeg" loading="lazy"></figure>
<p>电气元件：</p>
<table>
<thead>
<tr>
<th>元器件</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>MPU9250</td>
<td>1</td>
</tr>
<tr>
<td>Raspberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>电气接线图：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/mpu9250_spi_bb.png?raw=true" alt="mpu9250_spi_bb.png" loading="lazy"></figure>
<p>demo：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/spi.h&quot;

#define PIN_MISO 4
#define PIN_CS   5
#define PIN_SCK  6
#define PIN_MOSI 7

#define SPI_PORT spi0
#define READ_BIT 0x80

static inline void cs_select() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 0);  // Active low
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static inline void cs_deselect() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 1);
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static void mpu9250_reset() {
    // Two byte reset. First byte register, second byte data
    // There are a load more options to set up the device in different ways that could be added here
    uint8_t buf[] = {0x6B, 0x00};
    cs_select();
    spi_write_blocking(SPI_PORT, buf, 2);
    cs_deselect();
}


static void read_registers(uint8_t reg, uint8_t *buf, uint16_t len) {

    reg |= READ_BIT;
    cs_select();
    spi_write_blocking(SPI_PORT, &amp;reg, 1);
    sleep_ms(10);
    spi_read_blocking(SPI_PORT, 0, buf, len);
    cs_deselect();
    sleep_ms(10);
}


static void mpu9250_read_raw(int16_t accel[3], int16_t gyro[3], int16_t *temp) {
    uint8_t buffer[6];

    // Start reading acceleration registers from register 0x3B for 6 bytes
    read_registers(0x3B, buffer, 6);

    for (int i = 0; i &lt; 3; i++) {
        accel[i] = (buffer[i * 2] &lt;&lt; 8 | buffer[(i * 2) + 1]);
    }

    // Now gyro data from reg 0x43 for 6 bytes
    read_registers(0x43, buffer, 6);

    for (int i = 0; i &lt; 3; i++) {
        gyro[i] = (buffer[i * 2] &lt;&lt; 8 | buffer[(i * 2) + 1]);;
    }

    // Now temperature from reg 0x41 for 2 bytes
    read_registers(0x41, buffer, 2);

    *temp = buffer[0] &lt;&lt; 8 | buffer[1];
}

int main() {
    stdio_init_all();

    printf(&quot;Hello, MPU9250! Reading raw data from registers via SPI...\n&quot;);

    // This example will use SPI0 at 0.5MHz.
    spi_init(SPI_PORT, 500 * 1000);
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Chip select is active-low, so we'll initialise it to a driven-high state
    gpio_init(PIN_CS);
    gpio_set_dir(PIN_CS, GPIO_OUT);
    gpio_put(PIN_CS, 1);

    mpu9250_reset();

    // See if SPI is working - interrograte the device for its I2C ID number, should be 0x71
    uint8_t id;
    read_registers(0x75, &amp;id, 1);
    printf(&quot;I2C address is 0x%x\n&quot;, id);

    int16_t acceleration[3], gyro[3], temp;

    while (1) {
        mpu9250_read_raw(acceleration, gyro, &amp;temp);

        // These are the raw numbers from the chip, so will need tweaking to be really useful.
        // See the datasheet for more information
        printf(&quot;Acc. X = %d, Y = %d, Z = %d\n&quot;, acceleration[0], acceleration[1], acceleration[2]);
        printf(&quot;Gyro. X = %d, Y = %d, Z = %d\n&quot;, gyro[0], gyro[1], gyro[2]);
        // Temperature is simple so use the datasheet calculation to get deg C.
        // Note this is chip temperature.
        printf(&quot;Temp. = %f\n&quot;, (temp / 340.0) + 36.53);

        sleep_ms(100);
    }

    return 0;
}
</code></pre>
<p>CMakeLists.txt:</p>
<pre><code class="language-cmake">add_executable(mpu9250_spi
        mpu9250_spi.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(mpu9250_spi pico_stdlib hardware_spi)

# create map/bin/hex file etc.
pico_add_extra_outputs(mpu9250_spi)

# add url via pico_set_program_url
example_auto_set_url(mpu9250_spi)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[温湿度传感器]]></title>
        <id>https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/</id>
        <link href="https://zihan987.github.io/post/wen-shi-du-chuan-gan-qi/">
        </link>
        <updated>2021-08-12T05:18:27.000Z</updated>
        <summary type="html"><![CDATA[<p>DHT11、DHT21系列的传感器小伙伴们一定很熟悉，单片机一接，写个小的APP，可以做个小型的室内温湿度监测系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>DHT11、DHT21系列的传感器小伙伴们一定很熟悉，单片机一接，写个小的APP，可以做个小型的室内温湿度监测系统。</p>
<!-- more -->
<p>材料清单：</p>
<table>
<thead>
<tr>
<th>元器件名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>DHT11</td>
<td>1</td>
</tr>
<tr>
<td>Respberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>10k电阻</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>电气接线图：</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/pi-and-pico-uart-and-dht-sensor.png?raw=true" alt="pi-and-pico-uart-and-dht-sensor.png" loading="lazy"></figure>
<p>Demo:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/gpio.h&quot;

const uint LED_PIN = PICO_DEFAULT_LED_PIN;
const uint DHT_PIN = 15;
const uint MAX_TIMINGS = 85;

typedef struct {
    float humidity;
    float temp_celsius;
} dht_reading;

void read_from_dht(dht_reading *result);

int main() {
    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_init(DHT_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    while (1) {
        dht_reading reading;
        read_from_dht(&amp;reading);
        float fahrenheit = (reading.temp_celsius * 9 / 5) + 32;
        printf(&quot;Humidity = %.1f%%, Temperature = %.1fC (%.1fF)\n&quot;,
               reading.humidity, reading.temp_celsius, fahrenheit);

        sleep_ms(2000);
    }
}

void read_from_dht(dht_reading *result) {
    int data[5] = {0, 0, 0, 0, 0};
    uint last = 1;
    uint j = 0;

    gpio_set_dir(DHT_PIN, GPIO_OUT);
    gpio_put(DHT_PIN, 0);
    sleep_ms(20);
    gpio_set_dir(DHT_PIN, GPIO_IN);

    gpio_put(LED_PIN, 1);
    for (uint i = 0; i &lt; MAX_TIMINGS; i++) {
        uint count = 0;
        while (gpio_get(DHT_PIN) == last) {
            count++;
            sleep_us(1);
            if (count == 255) break;
        }
        last = gpio_get(DHT_PIN);
        if (count == 255) break;

        if ((i &gt;= 4) &amp;&amp; (i % 2 == 0)) {
            data[j / 8] &lt;&lt;= 1;
            if (count &gt; 16) data[j / 8] |= 1;
            j++;
        }
    }
    gpio_put(LED_PIN, 0);

    if ((j &gt;= 40) &amp;&amp; (data[4] == ((data[0] + data[1] + data[2] + data[3]) &amp; 0xFF))) {
        result-&gt;humidity = (float) ((data[0] &lt;&lt; 8) + data[1]) / 10;
        if (result-&gt;humidity &gt; 100) {
            result-&gt;humidity = data[0];
        }
        result-&gt;temp_celsius = (float) (((data[2] &amp; 0x7F) &lt;&lt; 8) + data[3]) / 10;
        if (result-&gt;temp_celsius &gt; 125) {
            result-&gt;temp_celsius = data[2];
        }
        if (data[2] &amp; 0x80) {
            result-&gt;temp_celsius = -result-&gt;temp_celsius;
        }
    } else {
        printf(&quot;Bad data\n&quot;);
    }
}
</code></pre>
<p>CMakelist.txt:</p>
<pre><code class="language-cmake">add_executable(dht
        dht.c
        )

target_link_libraries(dht pico_stdlib)

pico_add_extra_outputs(dht)

# add url via pico_set_program_url
example_auto_set_url(dht)
</code></pre>
<p>终端的输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/DHT1.jpg?raw=true" alt="DHT1.jpg" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WS2812 LED]]></title>
        <id>https://zihan987.github.io/post/ws2812-led/</id>
        <link href="https://zihan987.github.io/post/ws2812-led/">
        </link>
        <updated>2021-08-12T05:17:50.000Z</updated>
        <summary type="html"><![CDATA[<p>WS2812 LED是一种全彩的LED，我们平时看到的很多彩灯以及点阵就是这样的，因此第一个实践案例用来做这个真的不错。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WS2812 LED是一种全彩的LED，我们平时看到的很多彩灯以及点阵就是这样的，因此第一个实践案例用来做这个真的不错。</p>
<!-- more -->
<p>电气接线图：</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/WSB2.png?raw=true" alt="WSB2.png" loading="lazy"></figure>
<p>材料清单：</p>
<table>
<thead>
<tr>
<th>元器件</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raspberry Pi Pico</td>
<td>1</td>
</tr>
<tr>
<td>WS2812 LED</td>
<td>1</td>
</tr>
<tr>
<td>面包板</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>demo程序：</p>
<pre><code class="language-python">import array, time
from machine import Pin
import rp2

# Configure the number of WS2812 LEDs.
NUM_LEDS = 16
PIN_NUM = 6
brightness = 0.2

@rp2.asm_pio(sideset_init=rp2.PIO.OUT_LOW, out_shiftdir=rp2.PIO.SHIFT_LEFT, autopull=True, pull_thresh=24)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label(&quot;bitloop&quot;)
    out(x, 1)               .side(0)    [T3 - 1]
    jmp(not_x, &quot;do_zero&quot;)   .side(1)    [T1 - 1]
    jmp(&quot;bitloop&quot;)          .side(1)    [T2 - 1]
    label(&quot;do_zero&quot;)
    nop()                   .side(0)    [T2 - 1]
    wrap()


# Create the StateMachine with the ws2812 program, outputting on pin
sm = rp2.StateMachine(0, ws2812, freq=8_000_000, sideset_base=Pin(PIN_NUM))

# Start the StateMachine, it will wait for data on its FIFO.
sm.active(1)

# Display a pattern on the LEDs via an array of LED RGB values.
ar = array.array(&quot;I&quot;, [0 for _ in range(NUM_LEDS)])

##########################################################################
def pixels_show():
    dimmer_ar = array.array(&quot;I&quot;, [0 for _ in range(NUM_LEDS)])
    for i,c in enumerate(ar):
        r = int(((c &gt;&gt; 8) &amp; 0xFF) * brightness)
        g = int(((c &gt;&gt; 16) &amp; 0xFF) * brightness)
        b = int((c &amp; 0xFF) * brightness)
        dimmer_ar[i] = (g&lt;&lt;16) + (r&lt;&lt;8) + b
    sm.put(dimmer_ar, 8)
    time.sleep_ms(10)

def pixels_set(i, color):
    ar[i] = (color[1]&lt;&lt;16) + (color[0]&lt;&lt;8) + color[2]

def pixels_fill(color):
    for i in range(len(ar)):
        pixels_set(i, color)

def color_chase(color, wait):
    for i in range(NUM_LEDS):
        pixels_set(i, color)
        time.sleep(wait)
        pixels_show()
    time.sleep(0.2)
 
def wheel(pos):
    # Input a value 0 to 255 to get a color value.
    # The colours are a transition r - g - b - back to r.
    if pos &lt; 0 or pos &gt; 255:
        return (0, 0, 0)
    if pos &lt; 85:
        return (255 - pos * 3, pos * 3, 0)
    if pos &lt; 170:
        pos -= 85
        return (0, 255 - pos * 3, pos * 3)
    pos -= 170
    return (pos * 3, 0, 255 - pos * 3)
 
 
def rainbow_cycle(wait):
    for j in range(255):
        for i in range(NUM_LEDS):
            rc_index = (i * 256 // NUM_LEDS) + j
            pixels_set(i, wheel(rc_index &amp; 255))
        pixels_show()
        time.sleep(wait)

BLACK = (0, 0, 0)
RED = (255, 0, 0)
YELLOW = (255, 150, 0)
GREEN = (0, 255, 0)
CYAN = (0, 255, 255)
BLUE = (0, 0, 255)
PURPLE = (180, 0, 255)
WHITE = (255, 255, 255)
COLORS = (BLACK, RED, YELLOW, GREEN, CYAN, BLUE, PURPLE, WHITE)

print(&quot;fills&quot;)
for color in COLORS:       
    pixels_fill(color)
    pixels_show()
    time.sleep(0.2)

print(&quot;chases&quot;)
for color in COLORS:       
    color_chase(color, 0.01)

print(&quot;rainbow&quot;)
rainbow_cycle(0)
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/wsb1.png?raw=true" alt="wsb1.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PWM]]></title>
        <id>https://zihan987.github.io/post/pwm/</id>
        <link href="https://zihan987.github.io/post/pwm/">
        </link>
        <updated>2021-08-12T05:16:26.000Z</updated>
        <summary type="html"><![CDATA[<p>脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。</p>
]]></summary>
        <content type="html"><![CDATA[<p>脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">import time
from machine import Pin, PWM


# Construct PWM object, with LED on Pin(25).
pwm = PWM(Pin(25))

# Set the PWM frequency.
pwm.freq(1000)

# Fade the LED in and out a few times.
duty = 0
direction = 1
for _ in range(8 * 256):
    duty += direction
    if duty &gt; 255:
        duty = 255
        direction = -1
    elif duty &lt; 0:
        duty = 0
        direction = 1
    pwm.duty_u16(duty * duty)
    time.sleep(0.001)
</code></pre>
<h3 id="cc">C/C++</h3>
<p>以呼吸灯为例，LED为核心板上的。</p>
<pre><code class="language-c">#include &quot;pico/stdlib.h&quot;
#include &lt;stdio.h&gt;
#include &quot;pico/time.h&quot;
#include &quot;hardware/irq.h&quot;
#include &quot;hardware/pwm.h&quot;

void on_pwm_wrap() {
    static int fade = 0;
    static bool going_up = true;
    // Clear the interrupt flag that brought us here
    pwm_clear_irq(pwm_gpio_to_slice_num(PICO_DEFAULT_LED_PIN));

    if (going_up) {
        ++fade;
        if (fade &gt; 255) {
            fade = 255;
            going_up = false;
        }
    } else {
        --fade;
        if (fade &lt; 0) {
            fade = 0;
            going_up = true;
        }
    }
    // Square the fade value to make the LED's brightness appear more linear
    // Note this range matches with the wrap value
    pwm_set_gpio_level(PICO_DEFAULT_LED_PIN, fade * fade);
}

int main() {
    // Tell the LED pin that the PWM is in charge of its value.
    gpio_set_function(PICO_DEFAULT_LED_PIN, GPIO_FUNC_PWM);
    // Figure out which slice we just connected to the LED pin
    uint slice_num = pwm_gpio_to_slice_num(PICO_DEFAULT_LED_PIN);

    pwm_clear_irq(slice_num);
    pwm_set_irq_enabled(slice_num, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    // counter is allowed to wrap over its maximum range (0 to 2**16-1)
    pwm_config config = pwm_get_default_config();
    // Set divider, reduces counter clock to sysclock/this value
    pwm_config_set_clkdiv(&amp;config, 4.f);
    // Load the configuration into our PWM slice, and set it running.
    pwm_init(slice_num, &amp;config, true);

    while (1)
        tight_loop_contents();
}

</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(pwm_led_fade
        pwm_led_fade.c
        )

# Pull in our pico_stdlib which pulls in commonly used features
target_link_libraries(pwm_led_fade pico_stdlib hardware_pwm)

# create map/bin/hex file etc.
pico_add_extra_outputs(pwm_led_fade)

# add url via pico_set_program_url
example_auto_set_url(pwm_led_fade)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ADC]]></title>
        <id>https://zihan987.github.io/post/adc/</id>
        <link href="https://zihan987.github.io/post/adc/">
        </link>
        <updated>2021-08-12T05:15:36.000Z</updated>
        <summary type="html"><![CDATA[<p>模拟数字转换器即A/D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。通常的模数转换器是将一个输入电压信号转换为一个输出的数字信号。</p>
]]></summary>
        <content type="html"><![CDATA[<p>模拟数字转换器即A/D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。通常的模数转换器是将一个输入电压信号转换为一个输出的数字信号。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">import machine
import utime

sensor_temp = machine.ADC(4)
conversion_factor = 3.3 / (65535)

while True:
    reading = sensor_temp.read_u16() * conversion_factor
    
    # The temperature sensor measures the Vbe voltage of a biased bipolar diode, connected to the fifth ADC channel
    # Typically, Vbe = 0.706V at 27 degrees C, with a slope of -1.721mV (0.001721) per degree. 
    temperature = 27 - (reading - 0.706)/0.001721
    print(temperature)
    utime.sleep(2)
</code></pre>
<h3 id="cc">C/C++</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/adc.h&quot;  // For ADC input:
#include &quot;hardware/dma.h&quot;

#include &quot;pico/multicore.h&quot;// For resistor DAC output:
#include &quot;hardware/pio.h&quot;
#include &quot;resistor_dac.pio.h&quot;

// Channel 0 is GPIO26
#define CAPTURE_CHANNEL 0
#define CAPTURE_DEPTH 1000

uint8_t capture_buf[CAPTURE_DEPTH];

void core1_main();

int main() {
    stdio_init_all();

    // Send core 1 off to start driving the &quot;DAC&quot; whilst we configure the ADC.
    multicore_launch_core1(core1_main);

    // Init GPIO for analogue use: hi-Z, no pulls, disable digital input buffer.
    adc_gpio_init(26 + CAPTURE_CHANNEL);

    adc_init();
    adc_select_input(CAPTURE_CHANNEL);
    adc_fifo_setup(
        true,    // Write each completed conversion to the sample FIFO
        true,    // Enable DMA data request (DREQ)
        1,       // DREQ (and IRQ) asserted when at least 1 sample present
        false,   // We won't see the ERR bit because of 8 bit reads; disable.
        true     // Shift each sample to 8 bits when pushing to FIFO
    );

    adc_set_clkdiv(0);

    printf(&quot;Arming DMA\n&quot;);
    sleep_ms(1000);
    // Set up the DMA to start transferring data as soon as it appears in FIFO
    uint dma_chan = dma_claim_unused_channel(true);
    dma_channel_config cfg = dma_channel_get_default_config(dma_chan);

    // Reading from constant address, writing to incrementing byte addresses
    channel_config_set_transfer_data_size(&amp;cfg, DMA_SIZE_8);
    channel_config_set_read_increment(&amp;cfg, false);
    channel_config_set_write_increment(&amp;cfg, true);

    // Pace transfers based on availability of ADC samples
    channel_config_set_dreq(&amp;cfg, DREQ_ADC);

    dma_channel_configure(dma_chan, &amp;cfg,
        capture_buf,    // dst
        &amp;adc_hw-&gt;fifo,  // src
        CAPTURE_DEPTH,  // transfer count
        true            // start immediately
    );

    printf(&quot;Starting capture\n&quot;);
    adc_run(true);

    // Once DMA finishes, stop any new conversions from starting, and clean up
    // the FIFO in case the ADC was still mid-conversion.
    dma_channel_wait_for_finish_blocking(dma_chan);
    printf(&quot;Capture finished\n&quot;);
    adc_run(false);
    adc_fifo_drain();

    // Print samples to stdout so you can display them in pyplot, excel, matlab
    for (int i = 0; i &lt; CAPTURE_DEPTH; ++i) {
        printf(&quot;%-3d, &quot;, capture_buf[i]);
        if (i % 10 == 9)
            printf(&quot;\n&quot;);
    }
}

#define OUTPUT_FREQ_KHZ 5
#define SAMPLE_WIDTH 5
// This is the green channel on the VGA board
#define DAC_PIN_BASE 6

void core1_main() {
    PIO pio = pio0;
    uint sm = pio_claim_unused_sm(pio0, true);
    uint offset = pio_add_program(pio0, &amp;resistor_dac_5bit_program);
    resistor_dac_5bit_program_init(pio0, sm, offset,
        OUTPUT_FREQ_KHZ * 1000 * 2 * (1 &lt;&lt; SAMPLE_WIDTH), DAC_PIN_BASE);
    while (true) {
        // Triangle wave
        for (int i = 0; i &lt; (1 &lt;&lt; SAMPLE_WIDTH); ++i)
            pio_sm_put_blocking(pio, sm, i);
        for (int i = 0; i &lt; (1 &lt;&lt; SAMPLE_WIDTH); ++i)
            pio_sm_put_blocking(pio, sm, (1 &lt;&lt; SAMPLE_WIDTH) - 1 - i);
    }
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(adc_dma_capture
        dma_capture.c
        )

pico_generate_pio_header(adc_dma_capture ${CMAKE_CURRENT_LIST_DIR}/resistor_dac.pio)

target_link_libraries(adc_dma_capture
		pico_stdlib
		hardware_adc
		hardware_dma
		# For the dummy output:
		hardware_pio
		pico_multicore
		)

# create map/bin/hex file etc.
pico_add_extra_outputs(adc_dma_capture)

# add url via pico_set_program_url
example_auto_set_url(adc_dma_capture)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SPI]]></title>
        <id>https://zihan987.github.io/post/spi/</id>
        <link href="https://zihan987.github.io/post/spi/">
        </link>
        <updated>2021-08-12T05:13:41.000Z</updated>
        <summary type="html"><![CDATA[<p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。主要应用在EEPROM、Flash、实时时钟(RTC)、数模转换器(ADC)、网络控制器、MCU、数字信号处理器(DSP)以及数字信号解码器之间。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。主要应用在EEPROM、Flash、实时时钟(RTC)、数模转换器(ADC)、网络控制器、MCU、数字信号处理器(DSP)以及数字信号解码器之间。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<pre><code class="language-python">from machine import SPI

spi = SPI(0)
spi = SPI(0, 100_000)
spi = SPI(0, 100_000, polarity=1, phase=1)

spi.write('test')
spi.read(5)

buf = bytearray(3)
spi.write_readinto('out', buf)
</code></pre>
<h3 id="cc">C/C++</h3>
<p>以bme280温度压力传感器为例。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/bme280_spi_bb.png?raw=true" alt="bme280_spi_bb.png" loading="lazy"></figure>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/spi.h&quot;

#define PIN_MISO 16
#define PIN_CS   17
#define PIN_SCK  18
#define PIN_MOSI 19

#define SPI_PORT spi0
#define READ_BIT 0x80

int32_t t_fine;

uint16_t dig_T1;
int16_t dig_T2, dig_T3;
uint16_t dig_P1;
int16_t dig_P2, dig_P3, dig_P4, dig_P5, dig_P6, dig_P7, dig_P8, dig_P9;
uint8_t dig_H1, dig_H3;
int8_t dig_H6;
int16_t dig_H2, dig_H4, dig_H5;

/* The following compensation functions are required to convert from the raw ADC
data from the chip to something usable. Each chip has a different set of
compensation parameters stored on the chip at point of manufacture, which are
read from the chip at startup and used inthese routines.
*/
int32_t compensate_temp(int32_t adc_T) {
    int32_t var1, var2, T;
    var1 = ((((adc_T &gt;&gt; 3) - ((int32_t) dig_T1 &lt;&lt; 1))) * ((int32_t) dig_T2)) &gt;&gt; 11;
    var2 = (((((adc_T &gt;&gt; 4) - ((int32_t) dig_T1)) * ((adc_T &gt;&gt; 4) - ((int32_t) dig_T1))) &gt;&gt; 12) * ((int32_t) dig_T3))
            &gt;&gt; 14;

    t_fine = var1 + var2;
    T = (t_fine * 5 + 128) &gt;&gt; 8;
    return T;
}

uint32_t compensate_pressure(int32_t adc_P) {
    int32_t var1, var2;
    uint32_t p;
    var1 = (((int32_t) t_fine) &gt;&gt; 1) - (int32_t) 64000;
    var2 = (((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 11) * ((int32_t) dig_P6);
    var2 = var2 + ((var1 * ((int32_t) dig_P5)) &lt;&lt; 1);
    var2 = (var2 &gt;&gt; 2) + (((int32_t) dig_P4) &lt;&lt; 16);
    var1 = (((dig_P3 * (((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 13)) &gt;&gt; 3) + ((((int32_t) dig_P2) * var1) &gt;&gt; 1)) &gt;&gt; 18;
    var1 = ((((32768 + var1)) * ((int32_t) dig_P1)) &gt;&gt; 15);
    if (var1 == 0)
        return 0;

    p = (((uint32_t) (((int32_t) 1048576) - adc_P) - (var2 &gt;&gt; 12))) * 3125;
    if (p &lt; 0x80000000)
        p = (p &lt;&lt; 1) / ((uint32_t) var1);
    else
        p = (p / (uint32_t) var1) * 2;

    var1 = (((int32_t) dig_P9) * ((int32_t) (((p &gt;&gt; 3) * (p &gt;&gt; 3)) &gt;&gt; 13))) &gt;&gt; 12;
    var2 = (((int32_t) (p &gt;&gt; 2)) * ((int32_t) dig_P8)) &gt;&gt; 13;
    p = (uint32_t) ((int32_t) p + ((var1 + var2 + dig_P7) &gt;&gt; 4));

    return p;
}

uint32_t compensate_humidity(int32_t adc_H) {
    int32_t v_x1_u32r;
    v_x1_u32r = (t_fine - ((int32_t) 76800));
    v_x1_u32r = (((((adc_H &lt;&lt; 14) - (((int32_t) dig_H4) &lt;&lt; 20) - (((int32_t) dig_H5) * v_x1_u32r)) +
                   ((int32_t) 16384)) &gt;&gt; 15) * (((((((v_x1_u32r * ((int32_t) dig_H6)) &gt;&gt; 10) * (((v_x1_u32r *
                                                                                                  ((int32_t) dig_H3))
            &gt;&gt; 11) + ((int32_t) 32768))) &gt;&gt; 10) + ((int32_t) 2097152)) *
                                                 ((int32_t) dig_H2) + 8192) &gt;&gt; 14));
    v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r &gt;&gt; 15) * (v_x1_u32r &gt;&gt; 15)) &gt;&gt; 7) * ((int32_t) dig_H1)) &gt;&gt; 4));
    v_x1_u32r = (v_x1_u32r &lt; 0 ? 0 : v_x1_u32r);
    v_x1_u32r = (v_x1_u32r &gt; 419430400 ? 419430400 : v_x1_u32r);

    return (uint32_t) (v_x1_u32r &gt;&gt; 12);
}

static inline void cs_select() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 0);  // Active low
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static inline void cs_deselect() {
    asm volatile(&quot;nop \n nop \n nop&quot;);
    gpio_put(PIN_CS, 1);
    asm volatile(&quot;nop \n nop \n nop&quot;);
}

static void write_register(uint8_t reg, uint8_t data) {
    uint8_t buf[2];
    buf[0] = reg &amp; 0x7f;  // remove read bit as this is a write
    buf[1] = data;
    cs_select();
    spi_write_blocking(SPI_PORT, buf, 2);
    cs_deselect();
    sleep_ms(10);
}

static void read_registers(uint8_t reg, uint8_t *buf, uint16_t len) {
    // For this particular device, we send the device the register we want to read
    // first, then subsequently read from the device. The register is auto incrementing
    // so we don't need to keep sending the register we want, just the first.
    reg |= READ_BIT;
    cs_select();
    spi_write_blocking(SPI_PORT, &amp;reg, 1);
    sleep_ms(10);
    spi_read_blocking(SPI_PORT, 0, buf, len);
    cs_deselect();
    sleep_ms(10);
}

/* This function reads the manufacturing assigned compensation parameters from the device */
void read_compensation_parameters() {
    uint8_t buffer[26];

    read_registers(0x88, buffer, 24);

    dig_T1 = buffer[0] | (buffer[1] &lt;&lt; 8);
    dig_T2 = buffer[2] | (buffer[3] &lt;&lt; 8);
    dig_T3 = buffer[4] | (buffer[5] &lt;&lt; 8);

    dig_P1 = buffer[6] | (buffer[7] &lt;&lt; 8);
    dig_P2 = buffer[8] | (buffer[9] &lt;&lt; 8);
    dig_P3 = buffer[10] | (buffer[11] &lt;&lt; 8);
    dig_P4 = buffer[12] | (buffer[13] &lt;&lt; 8);
    dig_P5 = buffer[14] | (buffer[15] &lt;&lt; 8);
    dig_P6 = buffer[16] | (buffer[17] &lt;&lt; 8);
    dig_P7 = buffer[18] | (buffer[19] &lt;&lt; 8);
    dig_P8 = buffer[20] | (buffer[21] &lt;&lt; 8);
    dig_P9 = buffer[22] | (buffer[23] &lt;&lt; 8);

    dig_H1 = buffer[25];

    read_registers(0xE1, buffer, 8);

    dig_H2 = buffer[0] | (buffer[1] &lt;&lt; 8);
    dig_H3 = (int8_t) buffer[2];
    dig_H4 = buffer[3] &lt;&lt; 4 | (buffer[4] &amp; 0xf);
    dig_H5 = (buffer[5] &gt;&gt; 4) | (buffer[6] &lt;&lt; 4);
    dig_H6 = (int8_t) buffer[7];
}

static void bme280_read_raw(int32_t *humidity, int32_t *pressure, int32_t *temperature) {
    uint8_t buffer[8];

    read_registers(0xF7, buffer, 8);
    *pressure = ((uint32_t) buffer[0] &lt;&lt; 12) | ((uint32_t) buffer[1] &lt;&lt; 4) | (buffer[2] &gt;&gt; 4);
    *temperature = ((uint32_t) buffer[3] &lt;&lt; 12) | ((uint32_t) buffer[4] &lt;&lt; 4) | (buffer[5] &gt;&gt; 4);
    *humidity = (uint32_t) buffer[6] &lt;&lt; 8 | buffer[7];
}

int main() {
    stdio_init_all();

    printf(&quot;Hello, bme280! Reading raw data from registers via SPI...\n&quot;);

    // This example will use SPI0 at 0.5MHz.
    spi_init(SPI_PORT, 500 * 1000);
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Chip select is active-low, so we'll initialise it to a driven-high state
    gpio_init(PIN_CS);
    gpio_set_dir(PIN_CS, GPIO_OUT);
    gpio_put(PIN_CS, 1);

    // See if SPI is working - interrograte the device for its I2C ID number, should be 0x60
    uint8_t id;
    read_registers(0xD0, &amp;id, 1);
    printf(&quot;Chip ID is 0x%x\n&quot;, id);

    read_compensation_parameters();

    write_register(0xF2, 0x1); // Humidity oversampling register - going for x1
    write_register(0xF4, 0x27);// Set rest of oversampling modes and run mode to normal

    int32_t humidity, pressure, temperature;

    while (1) {
        bme280_read_raw(&amp;humidity, &amp;pressure, &amp;temperature);

        // These are the raw numbers from the chip, so we need to run through the
        // compensations to get human understandable numbers
        pressure = compensate_pressure(pressure);
        temperature = compensate_temp(temperature);
        humidity = compensate_humidity(humidity);

        printf(&quot;Humidity = %.2f%%\n&quot;, humidity / 1024.0);
        printf(&quot;Pressure = %dPa\n&quot;, pressure);
        printf(&quot;Temp. = %.2fC\n&quot;, temperature / 100.0);

        sleep_ms(1000);
    }

    return 0;
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">add_executable(bme280_spi
        bme280_spi.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(bme280_spi pico_stdlib hardware_spi)

# create map/bin/hex file etc.
pico_add_extra_outputs(bme280_spi)

# add url via pico_set_program_url
example_auto_set_url(bme280_spi)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[I2C]]></title>
        <id>https://zihan987.github.io/post/i2c/</id>
        <link href="https://zihan987.github.io/post/i2c/">
        </link>
        <updated>2021-08-12T05:11:12.000Z</updated>
        <summary type="html"><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。<a href="https://baike.baidu.com/item/SDA">SDA</a>(串行数据线)和<a href="https://baike.baidu.com/item/SCL">SCL</a>(串行时钟线)都是双向I/O线，接口电路为<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA">开漏输出</a>。需通过<a href="https://baike.baidu.com/item/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB">上拉电阻</a>接电源VCC．当总线空闲时。两根线都是<a href="https://baike.baidu.com/item/%E9%AB%98%E7%94%B5%E5%B9%B3">高电平</a>，连接总线的外同器件都是<a href="https://baike.baidu.com/item/CMOS">CMOS</a>器件，输出级也是开漏电路。</p>
]]></summary>
        <content type="html"><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。<a href="https://baike.baidu.com/item/SDA">SDA</a>(串行数据线)和<a href="https://baike.baidu.com/item/SCL">SCL</a>(串行时钟线)都是双向I/O线，接口电路为<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA">开漏输出</a>。需通过<a href="https://baike.baidu.com/item/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB">上拉电阻</a>接电源VCC．当总线空闲时。两根线都是<a href="https://baike.baidu.com/item/%E9%AB%98%E7%94%B5%E5%B9%B3">高电平</a>，连接总线的外同器件都是<a href="https://baike.baidu.com/item/CMOS">CMOS</a>器件，输出级也是开漏电路。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<p>我们以OLED屏幕的通信为例。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/pico-and-oled.png?raw=true" alt="pico-and-oled.png" loading="lazy"></figure>
<pre><code class="language-python">from machine import I2C, ADC
from sh1106 import SH1106_I2C
import framebuf


WIDTH  = 128                                            # oled display width
HEIGHT = 128                                            # oled display height

i2c = I2C(0)                                            # Init I2C using I2C0 defaults, SCL=Pin(GP9), SDA=Pin(GP8), freq=400000
print(&quot;I2C Address      : &quot;+hex(i2c.scan()[0]).upper()) # Display device address
print(&quot;I2C Configuration: &quot;+str(i2c))                   # Display I2C config


oled = SH1106_I2C(WIDTH, HEIGHT, i2c)                  # Init oled display

# Raspberry Pi logo as 32x32 bytearray
buffer = bytearray(b&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00|?\x00\x01\x86@\x80\x01\x01\x80\x80\x01\x11\x88\x80\x01\x05\xa0\x80\x00\x83\xc1\x00\x00C\xe3\x00\x00~\xfc\x00\x00L'\x00\x00\x9c\x11\x00\x00\xbf\xfd\x00\x00\xe1\x87\x00\x01\xc1\x83\x80\x02A\x82@\x02A\x82@\x02\xc1\xc2@\x02\xf6&gt;\xc0\x01\xfc=\x80\x01\x18\x18\x80\x01\x88\x10\x80\x00\x8c!\x00\x00\x87\xf1\x00\x00\x7f\xf6\x00\x008\x1c\x00\x00\x0c \x00\x00\x03\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;)

# Load the raspberry pi logo into the framebuffer (the image is 32x32)
fb = framebuf.FrameBuffer(buffer, 32, 32, framebuf.MONO_HLSB)

# Clear the oled display in case it has junk on it.
oled.fill(0)

# Blit the image from the framebuffer to the oled display
oled.blit(fb, 96, 0)

# Add some text
oled.text(&quot;Raspberry Pi&quot;,5,5)
oled.text(&quot;Pico&quot;,5,15)

# Finally update the oled display so the image &amp; text is displayed
oled.show()
</code></pre>
<h3 id="cc">C/C++</h3>
<p>我们以LCD1602为例。</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/zihan987/Raspberry-Pi-Pico/blob/main/images/lcd_1602_i2c_bb.png?raw=true" alt="lcd_1602_i2c_bb.png" loading="lazy"></figure>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/i2c.h&quot;
#include &quot;pico/binary_info.h&quot;

/* Example code to drive a 16x2 LCD panel via a I2C bridge chip (e.g. PCF8574)
   NOTE: The panel must be capable of being driven at 3.3v NOT 5v. The Pico
   GPIO (and therefor I2C) cannot be used at 5v.
   You will need to use a level shifter on the I2C lines if you want to run the
   board at 5v.
   Connections on Raspberry Pi Pico board, other boards may vary.
   GPIO 4 (pin 6)-&gt; SDA on LCD bridge board
   GPIO 5 (pin 7)-&gt; SCL on LCD bridge board
   3.3v (pin 36) -&gt; VCC on LCD bridge board
   GND (pin 38)  -&gt; GND on LCD bridge board
*/
// commands
const int LCD_CLEARDISPLAY = 0x01;
const int LCD_RETURNHOME = 0x02;
const int LCD_ENTRYMODESET = 0x04;
const int LCD_DISPLAYCONTROL = 0x08;
const int LCD_CURSORSHIFT = 0x10;
const int LCD_FUNCTIONSET = 0x20;
const int LCD_SETCGRAMADDR = 0x40;
const int LCD_SETDDRAMADDR = 0x80;

// flags for display entry mode
const int LCD_ENTRYSHIFTINCREMENT = 0x01;
const int LCD_ENTRYLEFT = 0x02;

// flags for display and cursor control
const int LCD_BLINKON = 0x01;
const int LCD_CURSORON = 0x02;
const int LCD_DISPLAYON = 0x04;

// flags for display and cursor shift
const int LCD_MOVERIGHT = 0x04;
const int LCD_DISPLAYMOVE = 0x08;

// flags for function set
const int LCD_5x10DOTS = 0x04;
const int LCD_2LINE = 0x08;
const int LCD_8BITMODE = 0x10;

// flag for backlight control
const int LCD_BACKLIGHT = 0x08;

const int LCD_ENABLE_BIT = 0x04;

#define I2C_PORT i2c0
// By default these LCD display drivers are on bus address 0x27
static int addr = 0x27;

// Modes for lcd_send_byte
#define LCD_CHARACTER  1
#define LCD_COMMAND    0

#define MAX_LINES      2
#define MAX_CHARS      16

/* Quick helper function for single byte transfers */
void i2c_write_byte(uint8_t val) {
    i2c_write_blocking(I2C_PORT, addr, &amp;val, 1, false);
}

void lcd_toggle_enable(uint8_t val) {
    // Toggle enable pin on LCD display
    // We cannot do this too quickly or things don't work
#define DELAY_US 600
    sleep_us(DELAY_US);
    i2c_write_byte(val | LCD_ENABLE_BIT);
    sleep_us(DELAY_US);
    i2c_write_byte(val &amp; ~LCD_ENABLE_BIT);
    sleep_us(DELAY_US);
}

// The display is sent a byte as two separate nibble transfers
void lcd_send_byte(uint8_t val, int mode) {
    uint8_t high = mode | (val &amp; 0xF0) | LCD_BACKLIGHT;
    uint8_t low = mode | ((val &lt;&lt; 4) &amp; 0xF0) | LCD_BACKLIGHT;

    i2c_write_byte(high);
    lcd_toggle_enable(high);
    i2c_write_byte(low);
    lcd_toggle_enable(low);
}

void lcd_clear(void) {
    lcd_send_byte(LCD_CLEARDISPLAY, LCD_COMMAND);
}

// go to location on LCD
void lcd_set_cursor(int line, int position) {
    int val = (line == 0) ? 0x80 + position : 0xC0 + position;
    lcd_send_byte(val, LCD_COMMAND);
}

static void inline lcd_char(char val) {
    lcd_send_byte(val, LCD_CHARACTER);
}

void lcd_string(const char *s) {
    while (*s) {
        lcd_char(*s++);
    }
}

void lcd_init() {
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x03, LCD_COMMAND);
    lcd_send_byte(0x02, LCD_COMMAND);

    lcd_send_byte(LCD_ENTRYMODESET | LCD_ENTRYLEFT, LCD_COMMAND);
    lcd_send_byte(LCD_FUNCTIONSET | LCD_2LINE, LCD_COMMAND);
    lcd_send_byte(LCD_DISPLAYCONTROL | LCD_DISPLAYON, LCD_COMMAND);
    lcd_clear();
}

int main() {
    // This example will use I2C0 on GPIO4 (SDA) and GPIO5 (SCL)
    i2c_init(I2C_PORT, 100 * 1000);
    gpio_set_function(4, GPIO_FUNC_I2C);
    gpio_set_function(5, GPIO_FUNC_I2C);
    gpio_pull_up(4);
    gpio_pull_up(5);
    // Make the I2C pins available to picotool
    bi_decl( bi_2pins_with_func(4, 5, GPIO_FUNC_I2C));

    lcd_init();

    static uint8_t *message[] =
            {
                    &quot;RP2040 by&quot;, &quot;Raspberry Pi&quot;,
                    &quot;A brand new&quot;, &quot;microcontroller&quot;,
                    &quot;Twin core M0&quot;, &quot;Full C SDK&quot;,
                    &quot;More power in&quot;, &quot;your product&quot;,
                    &quot;More beans&quot;, &quot;than Heinz!&quot;
            };

    while (1) {
        for (int m = 0; m &lt; sizeof(message) / sizeof(message[0]); m += MAX_LINES) {
            for (int line = 0; line &lt; MAX_LINES; line++) {
                lcd_set_cursor(line, (MAX_CHARS / 2) - strlen(message[m + line]) / 2);
                lcd_string(message[m + line]);
            }
            sleep_ms(2000);
            lcd_clear();
        }
    }

    return 0;
}
</code></pre>
<p>CMakeList.txt:</p>
<pre><code class="language-cmake">  
add_executable(lcd_1602_i2c
        lcd_1602_i2c.c
        )

# Pull in our (to be renamed) simple get you started dependencies
target_link_libraries(lcd_1602_i2c pico_stdlib hardware_i2c)

# create map/bin/hex file etc.
pico_add_extra_outputs(lcd_1602_i2c)

# add url via pico_set_program_url
example_auto_set_url(lcd_1602_i2c)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中断、定时器]]></title>
        <id>https://zihan987.github.io/post/zhong-duan-ding-shi-qi/</id>
        <link href="https://zihan987.github.io/post/zhong-duan-ding-shi-qi/">
        </link>
        <updated>2021-08-12T05:09:23.000Z</updated>
        <summary type="html"><![CDATA[<p>中断和定时器是CPU必不可少的部分，详细的介绍这里不过多赘述，我们直接看一下代码。定时器的代码主要结合C去讲解，这样比较清楚。</p>
]]></summary>
        <content type="html"><![CDATA[<p>中断和定时器是CPU必不可少的部分，详细的介绍这里不过多赘述，我们直接看一下代码。定时器的代码主要结合C去讲解，这样比较清楚。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<p>中断</p>
<pre><code class="language-python">from machine import Pin

p2 = Pin(2, Pin.IN, Pin.PULL_UP)
p2.irq(lambda pin: print(&quot;IRQ with flags:&quot;, pin.irq().flags()),
Pin.IRQ_FALLING)
</code></pre>
<h3 id="cc">C/C++</h3>
<p>定时器功能也很基础,而且只有一个,主要功能如下:</p>
<ul>
<li>64位计数器 (频率固定1MHz,所以要好几千年才能溢出)</li>
<li>4个闹钟 (闹钟是只匹配低32B,最大间隔4295秒)</li>
<li>寄存器自带映射,所以多个处理器同时访问也不用考虑竞争问题(无需考虑竞争问题)</li>
</ul>
<p>其中ALARM功能只会发起一次中断,中断发生后就会清除ARMED位,所有函数都有他的毫秒版本和微秒版本。</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;pico/util/queue.h&quot;

bool timer_callback(repeating_timer_t *rt);

queue_t sample_fifo;

// using struct as an example, but primitive types can be used too
typedef struct element {
    uint value;
} element_t;

const int FIFO_LENGTH = 32;

int main() {
    stdio_init_all();

    int hz = 25;

    queue_init(&amp;sample_fifo, sizeof(element_t), FIFO_LENGTH);

    repeating_timer_t timer;

    // negative timeout means exact delay (rather than delay between callbacks)
    if (!add_repeating_timer_us(-1000000 / hz, timer_callback, NULL, &amp;timer)) {
        printf(&quot;Failed to add timer\n&quot;);
        return 1;
    }

    // read some blocking

    for (int i = 0; i &lt; 10; i++) {
        element_t element;
        queue_remove_blocking(&amp;sample_fifo, &amp;element);
        printf(&quot;Got %d: %d\n&quot;, i, element.value);
    }

    // now retrieve all that are available periodically (simulate polling)
    for (int i = 0; i &lt; 10; i++) {
        int count = queue_get_level(&amp;sample_fifo);
        if (count) {
            printf(&quot;Getting %d, %d:\n&quot;, i, count);
            for (; count &gt; 0; count--) {
                element_t element;
                queue_remove_blocking(&amp;sample_fifo, &amp;element);
                printf(&quot;  got %d\n&quot;, element.value);
            }
        }
        sleep_us(5000000 / hz); // sleep for 5 times the sampling period
    }

    cancel_repeating_timer(&amp;timer);

    // drain any remaining
    element_t element;
    while (queue_try_remove(&amp;sample_fifo, &amp;element)) {
        printf(&quot;Got remaining %d\n&quot;, element.value);
    }

    queue_free(&amp;sample_fifo);
    printf(&quot;Done\n&quot;);
}

bool timer_callback(repeating_timer_t *rt) {
    static int v = 100;
    element_t element = {
            .value = v
    };
    v += 100;

    if (!queue_try_add(&amp;sample_fifo, &amp;element)) {
        printf(&quot;FIFO was full\n&quot;);
    }
    return true; // keep repeating
}
</code></pre>
<p>CMakeLists.txt:</p>
<pre><code class="language-cmake">if (NOT PICO_TIME_NO_ALARM_SUPPORT)
    add_executable(periodic_sampler
            periodic_sampler.c
            )

    # Pull in our (to be renamed) simple get you started dependencies
    target_link_libraries(periodic_sampler pico_stdlib)

    # create map/bin/hex file etc.
    pico_add_extra_outputs(periodic_sampler)

    # add url via pico_set_program_url
    example_auto_set_url(periodic_sampler)
endif()
</code></pre>
<p>lowlevel:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/timer.h&quot;
#include &quot;hardware/irq.h&quot;

/// \tag::get_time[]
// Simplest form of getting 64 bit time from the timer.
// It isn't safe when called from 2 cores because of the latching
// so isn't implemented this way in the sdk
static uint64_t get_time(void) {
    // Reading low latches the high value
    uint32_t lo = timer_hw-&gt;timelr;
    uint32_t hi = timer_hw-&gt;timehr;
    return ((uint64_t) hi &lt;&lt; 32u) | lo;
}
/// \end::get_time[]

/// \tag::alarm_standalone[]
// Use alarm 0
#define ALARM_NUM 0
#define ALARM_IRQ TIMER_IRQ_0

// Alarm interrupt handler
static volatile bool alarm_fired;

static void alarm_irq(void) {
    // Clear the alarm irq
    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);

    // Assume alarm 0 has fired
    printf(&quot;Alarm IRQ fired\n&quot;);
    alarm_fired = true;
}

static void alarm_in_us(uint32_t delay_us) {
    // Enable the interrupt for our alarm (the timer outputs 4 alarm irqs)
    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);
    // Set irq handler for alarm irq
    irq_set_exclusive_handler(ALARM_IRQ, alarm_irq);
    // Enable the alarm irq
    irq_set_enabled(ALARM_IRQ, true);
    // Enable interrupt in block and at processor

    // Alarm is only 32 bits so if trying to delay more
    // than that need to be careful and keep track of the upper
    // bits
    uint64_t target = timer_hw-&gt;timerawl + delay_us;

    // Write the lower 32 bits of the target time to the alarm which
    // will arm it
    timer_hw-&gt;alarm[ALARM_NUM] = (uint32_t) target;
}

int main() {
    stdio_init_all();
    printf(&quot;Timer lowlevel!\n&quot;);

    // Set alarm every 2 seconds
    while (1) {
        alarm_fired = false;
        alarm_in_us(1000000 * 2);
        // Wait for alarm to fire
        while (!alarm_fired);
    }
}
</code></pre>
<p>CMakeLists.txt:</p>
<pre><code class="language-cmake">if (PICO_ON_DEVICE)
    add_executable(timer_lowlevel
            timer_lowlevel.c)

    # Disable SDK alarm support for this lowlevel example
    set(PICO_TIME_DEFAULT_ALARM_POOL_DISABLED 1)

    target_link_libraries(timer_lowlevel pico_stdlib)

    # create map/bin/hex file etc.
    pico_add_extra_outputs(timer_lowlevel)

    # add url via pico_set_program_url
    example_auto_set_url(timer_lowlevel)
endif ()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UART]]></title>
        <id>https://zihan987.github.io/post/uart/</id>
        <link href="https://zihan987.github.io/post/uart/">
        </link>
        <updated>2021-08-12T05:07:39.000Z</updated>
        <summary type="html"><![CDATA[<p>USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。USART收发模块一般分为三大部分：<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E5%8F%91%E7%94%9F%E5%99%A8/9827742">时钟发生器</a>、数据发送器和接收器。控制<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>为所有的模块共享。</p>
]]></summary>
        <content type="html"><![CDATA[<p>USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。USART收发模块一般分为三大部分：<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E5%8F%91%E7%94%9F%E5%99%A8/9827742">时钟发生器</a>、数据发送器和接收器。控制<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>为所有的模块共享。</p>
<!-- more -->
<h3 id="micropython">MicroPython</h3>
<table>
<thead>
<tr>
<th>**Function</th>
<th><strong>Default</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>UART_BAUDRATE</td>
<td>115,200</td>
</tr>
<tr>
<td>UART_BITS</td>
<td>8</td>
</tr>
<tr>
<td>UART_STOP</td>
<td>1</td>
</tr>
<tr>
<td>UART0_TX</td>
<td>Pin 0</td>
</tr>
<tr>
<td>UART0_RX</td>
<td>Pin 1</td>
</tr>
<tr>
<td>UART1_TX</td>
<td>Pin 4</td>
</tr>
<tr>
<td>UART1_RX</td>
<td>Pin 5</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">from machine import Pin
from rp2 import PIO, StateMachine, asm_pio

UART_BAUD = 115200
PIN_BASE = 10
NUM_UARTS = 8


@asm_pio(sideset_init=PIO.OUT_HIGH, out_init=PIO.OUT_HIGH, out_shiftdir=PIO.SHIFT_RIGHT)
def uart_tx():
    # Block with TX deasserted until data available
    pull()
    # Initialise bit counter, assert start bit for 8 cycles
    set(x, 7)  .side(0)       [7]
    # Shift out 8 data bits, 8 execution cycles per bit
    label(&quot;bitloop&quot;)
    out(pins, 1)              [6]
    jmp(x_dec, &quot;bitloop&quot;)
    # Assert stop bit for 8 cycles total (incl 1 for pull())
    nop()      .side(1)       [6]


# Now we add 8 UART TXs, on pins 10 to 17. Use the same baud rate for all of them.
uarts = []
for i in range(NUM_UARTS):
    sm = StateMachine(
        i, uart_tx, freq=8 * UART_BAUD, sideset_base=Pin(PIN_BASE + i), out_base=Pin(PIN_BASE + i)
    )
    sm.active(1)
    uarts.append(sm)

# We can print characters from each UART by pushing them to the TX FIFO
def pio_uart_print(sm, s):
    for c in s:
        sm.put(ord(c))


# Print a different message from each UART
for i, u in enumerate(uarts):
    pio_uart_print(u, &quot;Hello from UART {}!\n&quot;.format(i))
</code></pre>
<h3 id="cc">C/C++</h3>
<p>以下为测试demo：</p>
<pre><code class="language-c">#include &quot;pico/stdlib.h&quot;
#include &quot;hardware/uart.h&quot;
#include &quot;hardware/irq.h&quot;


/// \tag::uart_advanced[]

#define UART_ID uart0
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY    UART_PARITY_NONE

// We are using pins 0 and 1, but see the GPIO function select table in the
// datasheet for information on which other pins can be used.
#define UART_TX_PIN 0
#define UART_RX_PIN 1

static int chars_rxed = 0;

// RX interrupt handler
void on_uart_rx() {
    while (uart_is_readable(UART_ID)) {
        uint8_t ch = uart_getc(UART_ID);
        // Can we send it back?
        if (uart_is_writable(UART_ID)) {
            // Change it slightly first!
            ch++;
            uart_putc(UART_ID, ch);
        }
        chars_rxed++;
    }
}

int main() {
    // Set up our UART with a basic baud rate.
    uart_init(UART_ID, 2400);

    // Set the TX and RX pins by using the function select on the GPIO
    // Set datasheet for more information on function select
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

    // Actually, we want a different speed
    // The call will return the actual baud rate selected, which will be as close as
    // possible to that requested
    int actual = uart_set_baudrate(UART_ID, BAUD_RATE);

    // Set UART flow control CTS/RTS, we don't want these, so turn them off
    uart_set_hw_flow(UART_ID, false, false);

    // Set our data format
    uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

    // Turn off FIFO's - we want to do this character by character
    uart_set_fifo_enabled(UART_ID, false);

    // Set up a RX interrupt
    // We need to set up the handler first
    // Select correct interrupt for the UART we are using
    int UART_IRQ = UART_ID == uart0 ? UART0_IRQ : UART1_IRQ;

    // And set up and enable the interrupt handlers
    irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
    irq_set_enabled(UART_IRQ, true);

    // Now enable the UART to send interrupts - RX only
    uart_set_irq_enables(UART_ID, true, false);

    // OK, all set up.
    // Lets send a basic string out, and then run a loop and wait for RX interrupts
    // The handler will count them, but also reflect the incoming data back with a slight change!
    uart_puts(UART_ID, &quot;\nHello, uart interrupts\n&quot;);

    while (1)
        tight_loop_contents();
}
</code></pre>
<p>CMakeLists.txt:</p>
<pre><code class="language-cmake">add_executable(uart_advanced
        uart_advanced.c
        )

# Pull in our pico_stdlib which pulls in commonly used features
target_link_libraries(uart_advanced pico_stdlib hardware_uart)

# create map/bin/hex file etc.
pico_add_extra_outputs(uart_advanced)

# add url via pico_set_program_url
example_auto_set_url(uart_advanced)
</code></pre>
]]></content>
    </entry>
</feed>